/*
      Jackal FET model
      Version 0.1
*/

`include "disciplines.h"
`include "constants.h"

`define   GMIN      1.0e-12
`define   SQRTPI    1.7724538509055160273
`define   MAX_EXP   60.0

/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////

module JACKAL_V07 ( vg, vd, vs, trap, Tj, igen );
    inout           vg, vd, vs, trap, Tj, igen ;
    electrical      vg, vd, vs, trap,     igen ;
    thermal                           Tj ;

    (* desc = "scaling factor", units = "" *)
    parameter real SF = 1.0 from (0:inf);
    
    (* desc = "pinch off voltage", units = "" *)
    parameter real VPO = -1.92 from (-inf:inf);
    
    (* desc = "pinch off voltage vs Vds", units = "" *)
    parameter real VPO_LAMBDA = -0.0025 from (-inf:0];

    (* desc = "Vg max", units = "" *)
    parameter real VMAX = 1.6 from (0:inf);
    
    (* desc = "Ids/Gm magnitude parameter", units = "" *)
    parameter real GM0 = 0.485 from (0:inf);
    
    (* desc = "Ids/Gm shaping parameter", units = "" *)
    parameter real GM1 = 6.0 from (-inf:inf);
    
    (* desc = "Ids/Gm shaping parameter", units = "" *)
    parameter real GM2 = 2.0 from (-inf:inf);
    
    (* desc = "Ids/Gm shaping parameter", units = "" *)
    parameter real GM3 = 2.3 from (-inf:inf);
    
    (* desc = "Ids/Gm shaping parameter", units = "" *)
    parameter real GM4 = 0.45 from (-inf:inf);
    
    (* desc = "GM0 vs Vds shaping parameter", units = "" *)
    parameter real GM0_ALPHA = 0.0000 from (-inf:inf);
    
    (* desc = "GM1 vs Vds shaping parameter", units = "" *)
    parameter real GM1_ALPHA = 0.0000 from (-inf:inf);
    
    (* desc = "GM2 vs Vds shaping parameter", units = "" *)
    parameter real GM2_ALPHA = 0.0000 from (-inf:inf);
    
    (* desc = "GM3 vs Vds shaping parameter", units = "" *)
    parameter real GM3_ALPHA = 0.0000 from (-inf:inf);
    
    (* desc = "GM4 vs Vds shaping parameter", units = "" *)
    parameter real GM4_ALPHA = 0.0000 from (-inf:inf);
    
    (* desc = "GM0 vs Vds shaping parameter", units = "" *)
    parameter real GM0_BETA = 0.0000 from (-inf:inf);
    
    (* desc = "GM1 vs Vds shaping parameter", units = "" *)
    parameter real GM1_BETA = 0.0000 from (-inf:inf);
    
    (* desc = "GM2 vs Vds shaping parameter", units = "" *)
    parameter real GM2_BETA = 0.0000 from (-inf:inf);
    
    (* desc = "GM3 vs Vds shaping parameter", units = "" *)
    parameter real GM3_BETA = 0.0000 from (-inf:inf);
    
    (* desc = "GM4 vs Vds shaping parameter", units = "" *)
    parameter real GM4_BETA = 0.0000 from (-inf:inf);
    
    (* desc = "Channel transit time delay", units = "" *)
    parameter real TAU = 4.0 from (-inf:inf);
    
    (* desc = "Channel transit time delay offset voltage", units = "" *)
    parameter real TAU_OFFSET = 25.0 from [0:inf);
    
    (* desc = "Channel transit time delay smoothing factor", units = "" *)
    parameter real TAU_ALPHA = 0.1 from [0:inf);
    
    (* desc = "Gate capacitance parameter", units = "" *)
    parameter real CG0 = 3.125e-12 from (-inf:inf);
    
    (* desc = "Gate capacitance parameter", units = "" *)
    parameter real CD0 = 3.125e-12 from (-inf:inf);
    
    (* desc = "Gate capacitance magnitude factor", units = "" *)
    parameter real C0 = 1.1e-12 from (-inf:inf);
    
    (* desc = "Gate capacitance shaping parameter", units = "" *)
    parameter real C1 = 0.045 from (-inf:inf);
    
    (* desc = "Gate capacitance shaping parameter", units = "" *)
    parameter real C2 = 0.0 from (-inf:inf);
    
    (* desc = "Gate capacitance Vds shaping factor", units = "" *)
    parameter real CG_ALPHA = 0.0 from (-inf:inf);
    
    (* desc = "Drain capacitance magnitude factor", units = "" *)
    parameter real D0 = -0.48e-12 from (-inf:inf);
    
    (* desc = "Drain capacitance shaping parameter", units = "" *)
    parameter real D1 = 0.02 from (-inf:inf);
    
    (* desc = "Leakage parameter", units = "" *)
    parameter real GLEAK1 = 0.0 from (-inf:inf);
    
    (* desc = "Leakage parameter", units = "" *)
    parameter real GLEAK2 = 0.0 from (-inf:inf);
    
    (* desc = "Leakage parameter", units = "" *)
    parameter real ALEAK = 0.0 from (-inf:inf);
    
    (* desc = "Nominal (extraction) temperature", units = "" *)
    parameter real TNOM = 25.0 from (-273.15:1000.0];
    
    (* desc = "Temperature scale factor for GM0", units = "" *)
    parameter real T_GM0 = -0.001650 from (-inf:inf);
    
    (* desc = "Temperature scale factor for GM1", units = "" *)
    parameter real T_GM1 = 0.0 from (-inf:inf);
    
    (* desc = "Temperature scale factor for GM2", units = "" *)
    parameter real T_GM2 = 0.0 from (-inf:inf);
    
    (* desc = "Temperature scale factor for GM3", units = "" *)
    parameter real T_GM3 = 0.0 from (-inf:inf);
    
    (* desc = "Temperature scale factor for GM4", units = "" *)
    parameter real T_GM4 = 0.0 from (-inf:inf);

    (* desc = "Temperature offset factor for VPO", units = "" *)
    parameter real T_VPO = -0.00020 from (-inf:inf);

    (* desc = "Temperature offset factor for VMAX", units = "" *)
    parameter real T_VMAX = -0.00420 from (-inf:inf);
    
    (* desc = "Temperature offset factor for Vds", units = "" *)
    parameter real T_VDS0 = 1.20 from (-inf:inf);
    
    (* desc = "Temperature multiplying factor for Vds", units = "" *)
    parameter real T_VDS1 = 0.008 from (-inf:inf);

`include "erf.h"    
    
	analog function real exp1;
		input x;
		real x;
		begin
			if (x > `MAX_EXP)
				exp1 = exp(`MAX_EXP)*(1.0 + (x-`MAX_EXP) + 0.5*(x-`MAX_EXP)*(x-`MAX_EXP));
			else
				exp1 = exp(x);	
		end
	endfunction
	
    analog function real Ids_helper1;
        // compute parameterized portions of the Ids function that can
        // be re-used to compute the total Ids
        input v, gm1, gm2;
        real  v, gm1, gm2;
        // local vars
        real f1, f2, e1, e2, sqrt_gm1_gm2_sq, inv_gm1_sqrtpi, inv_gm2_sqrtpi;
        real ids_a, ids_b, ids_c, ids_d, ids_e, ids_f, ids_g;
        begin
            f1 = erf(gm1*v);
            f2 = erf(gm2*v);
            e1 = exp1(-1.0*gm1*gm1*v*v);
            e2 = exp1(-1.0*gm2*gm2*v*v);
            sqrt_gm1_gm2_sq = sqrt(gm1*gm1+gm2*gm2);
            inv_gm1_sqrtpi = 1.0 / (gm1 * `SQRTPI);
            inv_gm2_sqrtpi = 1.0 / (gm2 * `SQRTPI);
            ids_a = v;
            ids_b = v*f1 + e1 * inv_gm1_sqrtpi;
            ids_c = v*f2 + e2 * inv_gm2_sqrtpi;
            ids_d = v*f1*f2;
            ids_e = f1 * e2 * inv_gm2_sqrtpi;
            ids_f = f2 * e1 * inv_gm1_sqrtpi;
            ids_g = -(1.0+erf(sqrt_gm1_gm2_sq*v)) * sqrt_gm1_gm2_sq / (gm1*gm2*`SQRTPI);
            Ids_helper1 = 0.25*(ids_a + ids_b + ids_c + ids_d + ids_e + ids_f + ids_g);
        end
    endfunction //Ids_helper1
    
    analog function real Ids_x;
        // compute Ids(x)
        input v, gm1, gm2, gm3, gm4, vpo, vmax;
        real  v, gm1, gm2, gm3, gm4, vpo, vmax;
        // local vars
        real v_offset, ids_multiplier;
        begin
            ids_multiplier = 0.5*((vmax-vpo)+sqrt((v-vpo)*(v-vpo)+gm4*gm4)-sqrt((v-vmax)*(v-vmax)+gm4*gm4))/(vmax-vpo);
            v_offset = gm3*ids_multiplier;
            Ids_x = Ids_helper1(v-vpo,gm1,gm2) - Ids_helper1(v-vpo-v_offset,gm1,gm2)*ids_multiplier;
        end
    endfunction //Ids_x

    
    analog function real Qgx_helper1;
        // compute parameterized portions of the Qgx function that can
        // be re-used to compute the total Qgx for a branch
        input v, c0, c1, f;
        real  v, c0, c1, f;
        // local vars
        begin
            Qgx_helper1 = c0*0.5*erf(c1*v)*v + c0*0.5*exp1(-1.0*(c1*c1*v*v))/(c1*`SQRTPI) + f*c0*0.5*v;
        end
    endfunction //Qgx_helper1
    
    
    
    /*****************************************************************************/
    /*****************************************************************************/

    analog begin : main
    
        real c0_scaled, d0_scaled;
        real Vgs, Vgd, Vds, Tjj, T_deg_C, Ids, Ids_no_delay, Vgs_Tau_vs_Vds, Vgd_Tau_vs_Vds;
        real Vgs_delay, Vgd_delay, Vds_delay;
        real tfact, gm0_tsf, gm1_tsf, gm2_tsf, gm3_tsf, gm4_tsf, vpo_toffs, vmax_toffs;
        real vpo_scaled, vmax_scaled;
        real gm0_scaled, gm1_scaled, gm2_scaled, gm3_scaled, gm4_scaled;
        real cg0_scaled, cd0_scaled;
        real erf_tfact_min, erf_tfact, erf_factor, ids_erf_factor, t_leak_factor;
        real Qgs1, Qgs2, Qgd1, Qgd2, Qgs, Qgd, Qds;
        real Ggs, Ggd, t_leakage, leak_diff;

        /////////////////////////////////////////////////////////////////////////
        @(initial_step) begin : atstart
            // compute constants
            c0_scaled = C0*SF;        
            d0_scaled = D0*SF;
            t_leak_factor = pow(1.0/273.15,1.0/3.0);
            leak_diff = GLEAK2 - GLEAK1;
        end
        /////////////////////////////////////////////////////////////////////////

//      Vgs = V(vg,vs) + V(trap);  //
//      Vgd = V(vg,vd) + V(trap);  //
//      Vds = Vgs - Vgd;  //
        
//      Vgs_delay = absdelay(V(vg,vs),TAU*1.0e-12) + V(trap);  //
//      Vgd_delay = absdelay(V(vg,vd),TAU*1.0e-12) + V(trap);  //
//      Vds_delay = Vgs_delay - Vgd_delay;  //

        Vgs = V(vg,vs) + V(trap);
        Vds = V(vd,vs);
        Vgd = V(vg,vd) + V(trap);
        
        Vgs_Tau_vs_Vds = TAU*1.0e-12*0.5*(1.0+erf(TAU_ALPHA*(Vds-TAU_OFFSET)));
        Vgd_Tau_vs_Vds = TAU*1.0e-12*0.5*(1.0+erf(TAU_ALPHA*(-Vds+TAU_OFFSET)));

        Vgs_delay = absdelay(V(vg,vs),Vgs_Tau_vs_Vds,TAU*1.0e-12) + V(trap);
        Vds_delay = Vds;
        Vgd_delay = absdelay(V(vg,vd),Vgd_Tau_vs_Vds,TAU*1.0e-12) + V(trap);

        //////////// constrain Tj between -150 and 600 deg C ///////////////////
        
        Tjj = Temp(Tj);
        T_deg_C = Tjj - 0.5*((Tjj-600.0)+sqrt((Tjj-600.0)*(Tjj-600.0)+2500.0)) + 0.5*((-150.0-Tjj)+sqrt((-150.0-Tjj)*(-150.0-Tjj)+2500.0));
        
        /////////////////// compute scaled parameters ///////////////////
        
        tfact = T_deg_C - TNOM;
        gm0_tsf = 1.0 + T_GM0*tfact;
        gm1_tsf = 1.0 + T_GM1*tfact;
        gm2_tsf = 1.0 + T_GM2*tfact;
        gm3_tsf = 1.0 + T_GM3*tfact;
        gm4_tsf = 1.0 + T_GM4*tfact;
        vpo_toffs = T_VPO*tfact;        
        vmax_toffs = T_VMAX*tfact;        
        
        vpo_scaled = VPO+vpo_toffs+VPO_LAMBDA*Vds;
        vmax_scaled = VMAX+vmax_toffs+VPO_LAMBDA*Vds;
        gm0_scaled = GM0*SF*gm0_tsf*((1.0-GM0_BETA)*exp1(GM0_ALPHA*Vds*Vds)+GM0_BETA);
        gm1_scaled = GM1*gm1_tsf*((1.0-GM1_BETA)*exp1(GM1_ALPHA*Vds*Vds)+GM1_BETA);
        gm2_scaled = GM2*gm2_tsf*((1.0-GM2_BETA)*exp1(GM2_ALPHA*Vds*Vds)+GM2_BETA);
        gm3_scaled = GM3*gm3_tsf*((1.0-GM3_BETA)*exp1(GM3_ALPHA*Vds*Vds)+GM3_BETA);
        gm4_scaled = GM4*gm4_tsf*((1.0-GM4_BETA)*exp1(GM4_ALPHA*Vds*Vds)+GM4_BETA);
        cg0_scaled = CG0*SF*gm0_tsf;        
        cd0_scaled = CD0*SF*gm0_tsf;        

        //////////// prevent (T_VDS0+T_VDS1*erf_tfact) from going to zero ///////////////////
        
        erf_tfact_min = -T_VDS0 / T_VDS1 + 1.0;
        erf_tfact = tfact + 0.5*((erf_tfact_min-tfact)+sqrt((erf_tfact_min-tfact)*(erf_tfact_min-tfact)+100.0));
        erf_factor = 0.475 / (T_VDS0+T_VDS1*erf_tfact);
        
        /////////////////// compute Ids and Pdiss ///////////////////

        ids_erf_factor = erf(Vds_delay*erf_factor);
        Ids = gm0_scaled*Ids_x(Vgs_delay,gm1_scaled,gm2_scaled,gm3_scaled,gm4_scaled,vpo_scaled,vmax_scaled)*0.5*(1.0+ids_erf_factor) - gm0_scaled*Ids_x(Vgd_delay,gm1_scaled,gm2_scaled,gm3_scaled,gm4_scaled,vpo_scaled,vmax_scaled)*0.5*(1.0-ids_erf_factor);
        Ids_no_delay = gm0_scaled*Ids_x(Vgs,gm1_scaled,gm2_scaled,gm3_scaled,gm4_scaled,vpo_scaled,vmax_scaled)*0.5*(1.0+ids_erf_factor) - gm0_scaled*Ids_x(Vgd,gm1_scaled,gm2_scaled,gm3_scaled,gm4_scaled,vpo_scaled,vmax_scaled)*0.5*(1.0-ids_erf_factor);
                
        /////////////////// compute charge ///////////////////
        
        Qgs1 = cg0_scaled*Ids_x(Vgs,gm1_scaled,gm2_scaled,gm3_scaled,gm4_scaled,vpo_scaled,vmax_scaled)*0.5*(1.0+erf(CG_ALPHA*(Vds-vpo_scaled)*erf_factor));        
        Qgs2 = Qgx_helper1(Vgs-C2,c0_scaled,C1,1.0);
        
        Qgd1 = cd0_scaled*Ids_x(Vgd,gm1_scaled,gm2_scaled,gm3_scaled,gm4_scaled,vpo_scaled,vmax_scaled)*0.5*(1.0-erf(CG_ALPHA*(Vds+vpo_scaled)*erf_factor));        
        Qgd2 = Qgx_helper1(Vgd-C2,c0_scaled,C1,1.0);
        
        Qgs = Qgs1 + Qgs2;
        Qgd = Qgd1 + Qgd2;
        Qds = Qgx_helper1(Vds,d0_scaled,D1,-1.0);
        
        /////////////////// compute leakage ///////////////////
        
        t_leakage = exp1(t_leak_factor-pow(1.0/(T_deg_C+273.15),1.0/3.0));
        Ggs = t_leakage*leak_diff*(1.0-exp1(-ALEAK*pow(V(vg,vs),4.0))+GLEAK1)*SF;
        Ggd = t_leakage*leak_diff*(1.0-exp1(-ALEAK*pow(V(vg,vd),4.0))+GLEAK1)*SF;
        
        /////////////////// compute outputs ///////////////////
        
        I(vd,vs)  <+ `GMIN*V(vd,vs)*0.0 + Ids + ddt(Qds);
        I(vg,vs)  <+ `GMIN*V(vg,vs)*0.0 + ddt(Qgs) + Ggs*V(vg,vs);
        I(vg,vd)  <+ `GMIN*V(vg,vd)*0.0 + ddt(Qgd) + Ggd*V(vg,vd);
        I(trap)   <+ V(trap);    // this is a 1 ohm resistor to ground that converts trap current to voltage
        Pwr(Tj)   <+ `GMIN*Temp(Tj) - Ids*Vds;
//      Pwr(Tj)   <+ `GMIN*Temp(Tj) - abs(Ids*Vds);  //
        I(igen)   <+ -Ids_no_delay;

    end
    
endmodule
