/*
      Jackal FET model
      Version 0.1
*/

`include "disciplines.h"
`include "constants.h"

`define   GMIN      1.0e-12
`define   SQRTPI    1.7724538509055160273

/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////

module JACKAL_V01 ( vg, vd, vs, trap, Tj );
    inout           vg, vd, vs, trap, Tj ;
    electrical      vg, vd, vs, trap     ;
    thermal                           Tj ;

    (* desc = "scaling factor", units = "" *)
    parameter real SF = 1.0 from (0:inf);
    
    (* desc = "pinch off voltage", units = "" *)
    parameter real VPO = -2.1 from (-inf:inf);

    (* desc = "Vg max", units = "" *)
    parameter real VMAX = 1.8 from (0:inf);
    
    (* desc = "Ids/Gm magnitude parameter", units = "" *)
    parameter real GM0 = 0.425 from (0:inf);
    
    (* desc = "Ids/Gm shaping parameter", units = "" *)
    parameter real GM1 = 3.0 from (-inf:inf);
    
    (* desc = "Ids/Gm shaping parameter", units = "" *)
    parameter real GM2 = 1.2 from (-inf:inf);
    
    (* desc = "Ids/Gm shaping parameter", units = "" *)
    parameter real GM3 = 0.45 from (-inf:inf);
    
    (* desc = "Ids/Gm shaping parameter", units = "" *)
    parameter real GM4 = 3.0 from (-inf:inf);
    
    (* desc = "Vds mutliplier for Ids", units = "" *)
    parameter real VDSF = 0.475 from (-inf:inf);
    
    (* desc = "Gate capacitance parameter", units = "" *)
    parameter real CG0 = 3.125e-12 from (-inf:inf);
    
    (* desc = "Gate capacitance magnitude factor", units = "" *)
    parameter real C0 = 1.1e-12 from (-inf:inf);
    
    (* desc = "Gate capacitance shaping parameter", units = "" *)
    parameter real C1 = 0.045 from (-inf:inf);
    
    (* desc = "Gate capacitance shaping parameter", units = "" *)
    parameter real C2 = 0.0 from (-inf:inf);
    
    (* desc = "Drain capacitance magnitude factor", units = "" *)
    parameter real D0 = -0.48e-12 from (-inf:inf);
    
    (* desc = "Drain capacitance shaping parameter", units = "" *)
    parameter real D1 = 0.02 from (-inf:inf);
    
    (* desc = "Nominal (extraction) temperature", units = "" *)
    parameter real TNOM = 25.0 from (-273.15:1000.0];
    
    (* desc = "Temperature scale factor for GM0", units = "" *)
    parameter real T_GM0 = -0.00187 from (-inf:inf);

    (* desc = "Temperature offset factor for VPO", units = "" *)
    parameter real T_VPO = -0.00125 from (-inf:inf);
    
    (* desc = "Temperature offset factor for Vds", units = "" *)
    parameter real T_VDS0 = 0.875 from (-inf:inf);
    
    (* desc = "Temperature multiplying factor for Vds", units = "" *)
    parameter real T_VDS1 = 0.005 from (-inf:inf);

`include "erf.h"    
    
    analog function real Ids_helper1;
        // compute parameterized portions of the Ids function that can
        // be re-used to compute the total Ids
        input v, gm1, gm2, idsa_mult, idsg_offset;
        real  v, gm1, gm2, idsa_mult, idsg_offset;
        // local vars
        real f1, f2, e1, e2, sqrt_gm1_gm2_sq, inv_gm1_sqrtpi, inv_gm2_sqrtpi;
        real ids_a, ids_b, ids_c, ids_d, ids_e, ids_f, ids_g;
        begin
            f1 = erf(gm1*v);
            f2 = erf(gm2*v);
            e1 = exp(-1.0*(pow((gm1*v),2)));
            e2 = exp(-1.0*(pow((gm2*v),2)));
            sqrt_gm1_gm2_sq = sqrt(gm1*gm1+gm2*gm2);
            inv_gm1_sqrtpi = 1.0 / (gm1 * `SQRTPI);
            inv_gm2_sqrtpi = 1.0 / (gm2 * `SQRTPI);
            ids_a = idsa_mult*v;
            ids_b = v*f1 + e1 * inv_gm1_sqrtpi;
            ids_c = v*f2 + e2 * inv_gm2_sqrtpi;
            ids_d = v*f1*f2;
            ids_e = f1 * e2 * inv_gm2_sqrtpi;
            ids_f = f2 * e1 * inv_gm1_sqrtpi;
            ids_g = -(erf(sqrt_gm1_gm2_sq*v)+idsg_offset) * sqrt_gm1_gm2_sq / (gm1*gm2*`SQRTPI);
            Ids_helper1 = 0.25*(ids_a + ids_b + ids_c + ids_d + ids_e + ids_f + ids_g);
        end
    endfunction //Ids_helper1
    
    analog function real Ids_x;
        // compute Ids(x)
        input v, gm1, gm2, gm3, gm4, vpo, vmax;
        real  v, gm1, gm2, gm3, gm4, vpo, vmax;
        begin
            Ids_x = Ids_helper1(v-vpo,gm1,gm2,1.0,1.0) - Ids_helper1(vmax-v,gm4,gm3,-3.0,-1.0)*0.5*(1.0+erf(gm1*(v-vpo)));
        end
    endfunction //Ids_x

    
    analog function real Qgx_helper1;
        // compute parameterized portions of the Qgx function that can
        // be re-used to compute the total Qgx for a branch
        input v, c0, c1, f;
        real  v, c0, c1, f;
        // local vars
        begin
            Qgx_helper1 = c0*0.5*erf(c1*v)*v + c0*0.5*exp(-1.0*(pow((c1*v),2)))/(c1*`SQRTPI) + f*c0*0.5*v;
        end
    endfunction //Qgx_helper1
    
    
    
    /*****************************************************************************/
    /*****************************************************************************/

    analog begin : main
    
        real c0_scaled, d0_scaled;
        real Vgs, Vgd, Vds, T_deg_C, Ids;
        real tfact, gm0_tsf, vpo_toffs;
        real vpo_scaled, gm0_scaled, cg0_scaled;
        real ids_erf_factor;
        real Qgs1, Qgs2, Qgs, Qgd, Qds;

        /////////////////////////////////////////////////////////////////////////
        @(initial_step) begin : atstart
            // compute constants
            c0_scaled = C0*SF;        
            d0_scaled = D0*SF;        
        end
        /////////////////////////////////////////////////////////////////////////

        Vgs = V(vg,vs) + V(trap);
        Vgd = V(vg,vd) + V(trap);
        Vds = Vgs - Vgd;
        T_deg_C = Temp(Tj);
        
        /////////////////// compute scaled parameters ///////////////////
        
        tfact = (T_deg_C - TNOM);
        gm0_tsf = 1.0 + T_GM0*tfact;
        vpo_toffs = T_VPO*tfact;        
        
        vpo_scaled = VPO+vpo_toffs;
        gm0_scaled = GM0*SF*gm0_tsf;
        cg0_scaled = CG0*SF*gm0_tsf;        
        
        /////////////////// compute Ids and Pdiss ///////////////////
        
        ids_erf_factor = erf(VDSF*Vds/(T_VDS0+T_VDS1*tfact));
        Ids = gm0_scaled*Ids_x(Vgs,GM1,GM2,GM3,GM4,vpo_scaled,VMAX)*0.5*(1.0+ids_erf_factor) - gm0_scaled*Ids_x(Vgd,GM1,GM2,GM3,GM4,vpo_scaled,VMAX)*0.5*(1.0-ids_erf_factor);
                
        /////////////////// compute charge ///////////////////
        
        Qgs1 = cg0_scaled*Ids_x(Vgs,GM1,GM2,GM3,GM4,vpo_scaled,VMAX);        
        Qgs2 = Qgx_helper1(Vgs-C2,c0_scaled,C1,1.0);
        
        Qgs = Qgs1+Qgs2;
        Qgd = Qgx_helper1(Vgd-C2,c0_scaled,C1,1.0);
        Qds = Qgx_helper1(Vds,d0_scaled,D1,-1.0);
        
        
        /////////////////// compute outputs ///////////////////
        
        I(vd,vs)  <+ `GMIN*V(vd,vs) + Ids + ddt(Qds);
        I(vg,vs)  <+ `GMIN*V(vg,vs) + ddt(Qgs);
        I(vg,vd)  <+ `GMIN*V(vg,vd) + ddt(Qgd);
        I(trap)   <+ V(trap);    // this is a 1 ohm resistor to ground that converts trap current to voltage
        Pwr(Tj)   <+ `GMIN*Temp(Tj) - Ids*Vds;

    end
    
endmodule







