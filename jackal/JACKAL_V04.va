/*
      Jackal FET model
      Version 0.1
*/

`include "disciplines.h"
`include "constants.h"

`define   GMIN      1.0e-12
`define   SQRTPI    1.7724538509055160273

/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////

module JACKAL_V04 ( vg, vd, vs, trap, Tj, igen );
    inout           vg, vd, vs, trap, Tj, igen ;
    electrical      vg, vd, vs, trap,     igen ;
    thermal                           Tj ;

    (* desc = "scaling factor", units = "" *)
    parameter real SF = 1.0 from (0:inf);
    
    (* desc = "pinch off voltage", units = "" *)
    parameter real VPO = -2.1 from (-inf:inf);

    (* desc = "Vg max", units = "" *)
    parameter real VMAX = 1.8 from (0:inf);
    
    (* desc = "Ids/Gm magnitude parameter", units = "" *)
    parameter real GM0 = 0.425 from (0:inf);
    
    (* desc = "Ids/Gm shaping parameter", units = "" *)
    parameter real GM1 = 3.0 from (-inf:inf);
    
    (* desc = "Ids/Gm shaping parameter", units = "" *)
    parameter real GM2 = 1.2 from (-inf:inf);
    
    (* desc = "Ids/Gm shaping parameter", units = "" *)
    parameter real GM3 = 0.45 from (-inf:inf);
    
    (* desc = "Ids/Gm shaping parameter", units = "" *)
    parameter real GM4 = 3.0 from (-inf:inf);
    
    (* desc = "Ids/Gm shaping parameter", units = "" *)
    parameter real GM5 = 3.0 from (-inf:inf);
    
    (* desc = "Ids/Gm shaping parameter", units = "" *)
    parameter real GM6 = 3.0 from (-inf:inf);
    
    (* desc = "Channel transit time delay", units = "" *)
    parameter real TAU = 0.0 from (-inf:inf);
    
    (* desc = "Gate capacitance parameter", units = "" *)
    parameter real CG0 = 3.125e-12 from (-inf:inf);
    
    (* desc = "Gate capacitance parameter", units = "" *)
    parameter real CD0 = 3.125e-12 from (-inf:inf);
    
    (* desc = "Gate capacitance magnitude factor", units = "" *)
    parameter real C0 = 1.1e-12 from (-inf:inf);
    
    (* desc = "Gate capacitance shaping parameter", units = "" *)
    parameter real C1 = 0.045 from (-inf:inf);
    
    (* desc = "Gate capacitance shaping parameter", units = "" *)
    parameter real C2 = 0.0 from (-inf:inf);
    
    (* desc = "Gate capacitance Vds shaping factor", units = "" *)
    parameter real CG_ALPHA = 0.0 from (-inf:inf);
    
    (* desc = "Drain capacitance magnitude factor", units = "" *)
    parameter real D0 = -0.48e-12 from (-inf:inf);
    
    (* desc = "Drain capacitance shaping parameter", units = "" *)
    parameter real D1 = 0.02 from (-inf:inf);
    
    (* desc = "Leakage parameter", units = "" *)
    parameter real GLEAK1 = 0.0 from (-inf:inf);
    
    (* desc = "Leakage parameter", units = "" *)
    parameter real GLEAK2 = 0.0 from (-inf:inf);
    
    (* desc = "Leakage parameter", units = "" *)
    parameter real ALEAK = 0.0 from (-inf:inf);
    
    (* desc = "Nominal (extraction) temperature", units = "" *)
    parameter real TNOM = 25.0 from (-273.15:1000.0];
    
    (* desc = "Temperature scale factor for GM0", units = "" *)
    parameter real T_GM0 = -0.00187 from (-inf:inf);

    (* desc = "Temperature offset factor for VPO", units = "" *)
    parameter real T_VPO = -0.00125 from (-inf:inf);

    (* desc = "Temperature offset factor for VMAX", units = "" *)
    parameter real T_VMAX = 0.00000 from (-inf:inf);
    
    (* desc = "Temperature offset factor for Vds", units = "" *)
    parameter real T_VDS0 = 0.875 from (-inf:inf);
    
    (* desc = "Temperature multiplying factor for Vds", units = "" *)
    parameter real T_VDS1 = 0.005 from (-inf:inf);

`include "erf.h"    
    
    analog function real Ids_helper1;
        // compute parameterized portions of the Ids function that can
        // be re-used to compute the total Ids
        input v, gm1, gm2, idsa_mult, idsg_offset;
        real  v, gm1, gm2, idsa_mult, idsg_offset;
        // local vars
        real f1, f2, e1, e2, sqrt_gm1_gm2_sq, inv_gm1_sqrtpi, inv_gm2_sqrtpi;
        real ids_a, ids_b, ids_c, ids_d, ids_e, ids_f, ids_g;
        begin
            f1 = erf(gm1*v);
            f2 = erf(gm2*v);
            e1 = exp(-1.0*(pow((gm1*v),2)));
            e2 = exp(-1.0*(pow((gm2*v),2)));
            sqrt_gm1_gm2_sq = sqrt(gm1*gm1+gm2*gm2);
            inv_gm1_sqrtpi = 1.0 / (gm1 * `SQRTPI);
            inv_gm2_sqrtpi = 1.0 / (gm2 * `SQRTPI);
            ids_a = idsa_mult*v;
            ids_b = v*f1 + e1 * inv_gm1_sqrtpi;
            ids_c = v*f2 + e2 * inv_gm2_sqrtpi;
            ids_d = v*f1*f2;
            ids_e = f1 * e2 * inv_gm2_sqrtpi;
            ids_f = f2 * e1 * inv_gm1_sqrtpi;
            ids_g = -(erf(sqrt_gm1_gm2_sq*v)+idsg_offset) * sqrt_gm1_gm2_sq / (gm1*gm2*`SQRTPI);
            Ids_helper1 = 0.25*(ids_a + ids_b + ids_c + ids_d + ids_e + ids_f + ids_g);
        end
    endfunction //Ids_helper1
    
    analog function real Ids_x;
        // compute Ids(x)
        input v, gm1, gm2, gm3, gm4, gm5, gm6, vpo, vmax;
        real  v, gm1, gm2, gm3, gm4, gm5, gm6, vpo, vmax;
        begin
            Ids_x = Ids_helper1(v-vpo,gm1,gm2,1.0,1.0) - Ids_helper1(vmax-v,gm4,gm3,-3.0,-1.0)*0.5*(1.0+erf(gm1*gm5*(v-vpo+gm6)));
        end
    endfunction //Ids_x

    
    analog function real Qgx_helper1;
        // compute parameterized portions of the Qgx function that can
        // be re-used to compute the total Qgx for a branch
        input v, c0, c1, f;
        real  v, c0, c1, f;
        // local vars
        begin
            Qgx_helper1 = c0*0.5*erf(c1*v)*v + c0*0.5*exp(-1.0*(pow((c1*v),2)))/(c1*`SQRTPI) + f*c0*0.5*v;
        end
    endfunction //Qgx_helper1
    
    
    
    /*****************************************************************************/
    /*****************************************************************************/

    analog begin : main
    
        real c0_scaled, d0_scaled;
        real Vgs, Vgd, Vds, T_deg_C, Ids;
        real Vgs_delay, Vgd_delay, Vds_delay;
        real tfact, gm0_tsf, vpo_toffs, vmax_toffs;
        real vpo_scaled, vmax_scaled, gm0_scaled, cg0_scaled, cd0_scaled;
        real erf_factor, ids_erf_factor, t_leak_factor;
        real Qgs1, Qgs2, Qgd1, Qgd2, Qgs, Qgd, Qds;
        real Ggs, Ggd, t_leakage, leak_diff;

        /////////////////////////////////////////////////////////////////////////
        @(initial_step) begin : atstart
            // compute constants
            c0_scaled = C0*SF;        
            d0_scaled = D0*SF;
            t_leak_factor = pow(1.0/273.15,1.0/3.0);
            leak_diff = GLEAK2 - GLEAK1;
        end
        /////////////////////////////////////////////////////////////////////////

        Vgs = V(vg,vs) + V(trap);
        Vgd = V(vg,vd) + V(trap);
        Vds = Vgs - Vgd;
        
        Vgs_delay = absdelay(V(vg,vs),TAU*1.0e-12) + V(trap);
        Vgd_delay = absdelay(V(vg,vd),TAU*1.0e-12) + V(trap);
        Vds_delay = Vgs_delay - Vgd_delay;
        
        T_deg_C = Temp(Tj);
        
        /////////////////// compute scaled parameters ///////////////////
        
        tfact = T_deg_C - TNOM;
        gm0_tsf = 1.0 + T_GM0*tfact;
        vpo_toffs = T_VPO*tfact;        
        vmax_toffs = T_VMAX*tfact;        
        
        vpo_scaled = VPO+vpo_toffs;
        vmax_scaled = VMAX+vmax_toffs;
        gm0_scaled = GM0*SF*gm0_tsf;
        cg0_scaled = CG0*SF*gm0_tsf;        
        cd0_scaled = CD0*SF*gm0_tsf;        
        
        /////////////////// compute Ids and Pdiss ///////////////////
        
        erf_factor = 0.475 / (T_VDS0+T_VDS1*tfact);
        ids_erf_factor = erf(Vds_delay*erf_factor);
        Ids = gm0_scaled*Ids_x(Vgs_delay,GM1,GM2,GM3,GM4,GM5,GM6,vpo_scaled,vmax_scaled)*0.5*(1.0+ids_erf_factor) - gm0_scaled*Ids_x(Vgd_delay,GM1,GM2,GM3,GM4,GM5,GM6,vpo_scaled,vmax_scaled)*0.5*(1.0-ids_erf_factor);
                
        /////////////////// compute charge ///////////////////
        
        Qgs1 = cg0_scaled*Ids_x(Vgs,GM1,GM2,GM3,GM4,GM5,GM6,vpo_scaled,vmax_scaled)*0.5*(1.0+erf(CG_ALPHA*(Vds-vpo_scaled)*erf_factor));        
        Qgs2 = Qgx_helper1(Vgs-C2,c0_scaled,C1,1.0);
        
        Qgd1 = cd0_scaled*Ids_x(Vgd,GM1,GM2,GM3,GM4,GM5,GM6,vpo_scaled,vmax_scaled)*0.5*(1.0-erf(CG_ALPHA*(Vds+vpo_scaled)*erf_factor));        
        Qgd2 = Qgx_helper1(Vgd-C2,c0_scaled,C1,1.0);
        
        Qgs = Qgs1 + Qgs2;
        Qgd = Qgd1 + Qgd2;
        Qds = Qgx_helper1(Vds,d0_scaled,D1,-1.0);
        
        /////////////////// compute leakage ///////////////////
        
        t_leakage = exp(t_leak_factor-pow(1.0/(T_deg_C+273.15),1.0/3.0));
        Ggs = t_leakage*leak_diff*(1.0-exp(-ALEAK*pow(V(vg,vs),4.0))+GLEAK1)*SF;
        Ggd = t_leakage*leak_diff*(1.0-exp(-ALEAK*pow(V(vg,vd),4.0))+GLEAK1)*SF;
        
        /////////////////// compute outputs ///////////////////
        
        I(vd,vs)  <+ `GMIN*V(vd,vs) + Ids + ddt(Qds);
        I(vg,vs)  <+ `GMIN*V(vg,vs) + ddt(Qgs) + Ggs*V(vg,vs);
        I(vg,vd)  <+ `GMIN*V(vg,vd) + ddt(Qgd) + Ggd*V(vg,vd);
        I(trap)   <+ V(trap);    // this is a 1 ohm resistor to ground that converts trap current to voltage
        Pwr(Tj)   <+ `GMIN*Temp(Tj) - Ids*Vds;
        I(igen)   <+ -Ids;

    end
    
endmodule
