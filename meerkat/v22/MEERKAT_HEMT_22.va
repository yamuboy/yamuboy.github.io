/*
      Meerkat HEMT Model
      Version 2.1 beta
      (C) January 2012
      Anthony Parker, Macquarie University


                         ,"user\\nonlinear\\MEERKAT22a"
                         ,"HEMT_Tj_ii_trap@mrkt.syf"
                         ,"Meerkat HEMT with impact ionisation, trap node, temperature, and breakdown"
                         ,"Macquarie University",2,EF_Default)
      
      Implement noise
                         
*/

`include "disciplines.h"
`include "constants.h"

// /////////////////////////////////////////////////////////////////////// /////////////////////////////////////////////////////////////////////// ///////////////////////////////////////////////////////////////////////

`define CURRENT_ABSTOL 1.0E-12

`define   GMIN    1.0E-12  // should be $simparam("GMIN", 1.0E-12) but this is not supported by AWR
`define   kWatts  0.001    // Scale power dissipation to 1 mA / W
`define   kKelvin 1000.0   // Scale temperature to 1 K / mV

// Global temperature mapping parameters. The value at the temperature node is mapped to a restricted range to enusure numerical stability.
`define   TEMPERATURE_UPPER_BOUND                2700.0     // greater than melting point
`define   TEMP_UPPER_BOUND_RADIUS_SQR_times4   144400.0     // 4*190*190, maps T = 2700 --> 2510
`define   TEMPERATURE_LOWER_BOUND_times2           70.0     // 35K - too cold for semiconductor action
`define   TEMP_LOWER_BOUND_RADIUS_SQR_times16   55010.6955  // chosen to map T = 300 --> 300

//`define KoverQ       0.000086173425
// Uncertainty         0.00000000015  http://physics.nist.gov/ 2008
`define   KoverQover4  0.00002154335625
`define   QoverK             11604.505681420925
`define   QoverK_times4      46418.0227256837

// /////////////////////////////////////////////////////////////////////// /////////////////////////////////////////////////////////////////////// ///////////////////////////////////////////////////////////////////////

// ##     ##    ######    #######    ##    ##   ##       ########            ######    ##    ##        #      ##     ##   ##     ##   ########   ##
// ###   ###   ##    ##   ##    ##   ##    ##   ##       ##                 ##    ##   ##    ##       ###     ###    ##   ###    ##   ##         ##
// ## # # ##   ##    ##   ##    ##   ##    ##   ##       ######             ##         ########      ## ##    ## #   ##   ## #   ##   ######     ##
// ##  #  ##   ##    ##   ##    ##   ##    ##   ##       ##                 ##         ##    ##     #######   ##  #  ##   ##  #  ##   ##         ##
// ##     ##   ##    ##   ##    ##   ##    ##   ##       ##                 ##    ##   ##    ##    ##     ##  ##   # ##   ##   # ##   ##         ##
// ##     ##    ######    #######     ######    #######  ########            ######    ##    ##   ##       ## ##    ###   ##    ###   ########   #######

module    MRKT22a   ( g, d, s, Tj, Impact_Ionization_Tunnelling, Trap_Potential );
    inout                g, d, s, Tj, Impact_Ionization_Tunnelling, Trap_Potential  ;
    electrical           g, d, s,     Impact_Ionization_Tunnelling, Trap_Potential  ;
    thermal                       Tj                                                ;

   (* desc = "Extraction Temperature\nTemperature at which parameters supplied here were extracted.", units = "K" *)               // TO BE CHECKED
   parameter real TNOM = 300.0 from (70:inf);               // TO BE CHECKED


   (* desc = "Channel-length reduction rate\nEquivalent to an Early voltage. Sets rate of length reduction of low field channel region.     ", units = "V" *)               // TO BE CHECKED
   parameter real LAMBDA=10.0 from (0:inf);               // TO BE CHECKED
   (* desc = "Channel-length reduction smoothing\nSets rate w.r.t. drain-source potential of onset of channel length reduction.             ", units = "V" *)               // TO BE CHECKED
   parameter real LAMBDA_S=0.1 from [0:inf);               // TO BE CHECKED
   (* desc = "Exponent of channel current\nExponent of the carrier density primitive.                                                       " *)               // TO BE CHECKED
   parameter real P=2.0 from (1:4);               // TO BE CHECKED
   (* desc = "Gate-junction built-in potential\nBuilt in potential at TNOM. Positive (>VTO) for n-channel. Negative (<VTO) for p-channel.   ", units = "V" *)               // TO BE CHECKED
   parameter real VBI=1.0 from (-inf:inf);               // TO BE CHECKED
   (* desc = "Gate-junction built-in potential temperature coefficient\nThe dependence of built-in potential on temperature. Scaled by k/q. " *)               // TO BE CHECKED
   parameter real VBI_T=0.0 from (-inf:inf);               // TO BE CHECKED
   (* desc = "Substhreshold region potential\nThe rate of low-field subthreshold current reduction is Q/SIGMA nepers per volt.              ", units = "V" *)               // TO BE CHECKED
   parameter real VST=0.1 from [0.01:inf);               // TO BE CHECKED
   (* desc = "Substhreshold region temperature coefficient\nThe dependence of low-field subthreshold current reduction rate on temperature. " *)               // TO BE CHECKED
   parameter real VST_T=0.0 from (-VST*P*4.3:inf);               // TO BE CHECKED
   (* desc = "Pinch-off potential\nNominal potential required to deplete the channel. For n-channel set VTO<VBI. For p-channel set VTO>VBI. ", units = "V" *)               // TO BE CHECKED
   parameter real VTO=-1.0 from (-inf:inf);               // TO BE CHECKED
   (* desc = "Drain-source velocity saturation potential\nProportional to channel length and effective saturation field strength.           ", units = "V" *)               // TO BE CHECKED
   parameter real XI=1.0 from [0:inf);               // TO BE CHECKED
   (* desc = "Relative width of field independent mobility\nScaled by XI to give potential of positive to negative vds transition.          " *)               // TO BE CHECKED
   parameter real XI_MU=0.1 from (0:inf);               // TO BE CHECKED
   (* desc = "Current saturation smoothing parameter\nWidth of transition to saturated velocity mode (from low to high field regions).      ", units = "V" *)               // TO BE CHECKED
   parameter real XI_SS=0.1 from [0.01:inf);               // TO BE CHECKED
   (* desc = "Ratio of field strength at peak velocity to equivalent saturated velocity field\nUnity for compound semis or zero for silicon." *)               // TO BE CHECKED
   parameter real XI_X=1.0 from (0:inf);               // TO BE CHECKED
   
   (* desc = "Current compression ratio\nReduces transconductance by this factor. Negative value increases tranconductance.                 ", units = "V" *)               // TO BE CHECKED
   parameter real ALPHA=0.0 from (-1:1);               // TO BE CHECKED
   (* desc = "Current compression position\nThe gate potential at the center of carrier density compression is set to (ALPHA_V*(VBI-VTO)).  " *)               // TO BE CHECKED
   parameter real ALPHA_V=1.0 from (0:5);               // TO BE CHECKED
   (* desc = "Current compression width\nSets width of the carrier density compression region to approximately (ALPHA_Z*ALSPA_V*(VBI-VTO)). " *)               // TO BE CHECKED
   parameter real ALPHA_Z=0.5 from (0:1];               // TO BE CHECKED
   (* desc = "Transconductance at low field\nLow-field open channel drain-source conductance of fully on FET at zero drain-source potential.", units = "S" *)               // TO BE CHECKED
   parameter real BETA=0.1 from [0:inf);               // TO BE CHECKED
   (* desc = "Normalized Drain Current Temperature Coefficient\nZero disables temperature dependence, unity gives maximum dependency.       " *)               // TO BE CHECKED
   parameter real BETA_TL=0.5 from [0:1];               // TO BE CHECKED
   (* desc = "Transit temperature for drift velocity\nLinear to inverse thermal coefficient transition temperature.                         ", units = "K" *)               // TO BE CHECKED
   parameter real BETA_TT=300.0 from [100:1000);               // TO BE CHECKED
   (* desc = "Gate-drain fringing capacitance                                                                                               ", units = "F" *)               // TO BE CHECKED
   parameter real CGDO = 0.0 from [0:inf);               // TO BE CHECKED
   (* desc = "Gate-source fringing capacitance                                                                                              ", units = "F" *)               // TO BE CHECKED
   parameter real CGSO = 0.0 from [0:inf);               // TO BE CHECKED
   (* desc = "Inverse intrinsic gain\nSets increase in pinch-off potential as drain potential increases. Effect reduces for open channel.   " *)               // TO BE CHECKED
   parameter real GAMMA = 0.0 from [0:1);               // TO BE CHECKED

   // /////////////////////////////////////////////////////////////////////// ///////////////////////////////////////////////////////////////////////               // TO BE CHECKED

   // Gate junction diode and breakdown parameters               // TO BE CHECKED
   (* desc = "Forward current emission coefficient\nNormally between 1 and 2" *)               // TO BE CHECKED
   parameter real DIODE_FWD_N = 1.0 from (0:inf);               // TO BE CHECKED
   (* desc = "Scale current of forward current\nIntercept at zero junction potential", units = "A" *)               // TO BE CHECKED
   parameter real DIODE_FWD_SCALE = 1.0E-10 from [0:inf);               // TO BE CHECKED
   (* desc = "Activation energy of thermal dependence of forward current\nRelated to the semiconductor band gap", units = "V" *)               // TO BE CHECKED
   parameter real DIODE_FWD_EG = 0.5 from (-5.0:5.0);               // TO BE CHECKED
   (* desc = "Forward current Arrhenius pre-factor temperature dependence index\nSet to 2 for Schottky junctions or 3 for PN junctions" *)               // TO BE CHECKED
   parameter real DIODE_FWD_XTI = 2.0 from [0:4.0);               // TO BE CHECKED

   (* desc = "Reverse current emission potential.\nNominaly at REV_V = BREAKDOWN_POTENTIAL / (REV_XTI + `QoverK / TNOM * REV_EG)", units = "V" *)               // TO BE CHECKED
   parameter real DIODE_REV_V = 1.0 from (0:inf);               // TO BE CHECKED

   (* desc = "Scale current of reverse current\nIntercept at zero junction potential", units = "A" *)               // TO BE CHECKED
   parameter real DIODE_REV_SCALE = 0.0 from [0:inf);               // TO BE CHECKED
   (* desc = "Activation energy of thermal dependence of reverse current\nTypically between 0 and 1 V", units = "V" *)               // TO BE CHECKED
   parameter real DIODE_REV_EG = 0.5 from (-5.0:5.0);               // TO BE CHECKED
   (* desc = "Reverse current Arrhenius pre-factor temperature dependence index\nNominally set to 2" *)               // TO BE CHECKED
   parameter real DIODE_REV_XTI = 2.0 from [0:4.0);               // TO BE CHECKED

   (* desc = "Junction capacitance at the turning point potential.", units = "F" *)               // TO BE CHECKED
   parameter real GJ_CAPACITANCE = 0.0 from (-inf:inf);               // TO BE CHECKED
   (* desc = "Depletion charge power law index." *)               // TO BE CHECKED
   parameter real CJ_P = 2.0 from (1.0:inf);               // TO BE CHECKED
   (* desc = "Gate-junction built-in potential\nBuilt in potential at TNOM. Positive (>VTO) for n-channel. Negative (<VTO) for p-channel.   ", units = "V" *)               // TO BE CHECKED
   parameter real CJ_VBI=1.0 from (-inf:inf);               // TO BE CHECKED
   (* desc = "Diode potential that completely depletes junction\nEquivalent to piching out all carriers", units = "V" *)               // TO BE CHECKED
   parameter real CJ_PINCH_OFF = (-1.0) from (-inf:VBI);               // TO BE CHECKED
   (* desc = "Substhreshold region potential\nThe rate of low-field subthreshold current reduction is Q/SIGMA nepers per volt.              ", units = "V" *)               // TO BE CHECKED
   parameter real CJ_VST=0.1 from [0.01:inf);               // TO BE CHECKED
   (* desc = "Inverse intrinsic gain\nSets increase in pinch-off potential as drain potential increases. Effect reduces for open channel.   " *)               // TO BE CHECKED
   parameter real CJ_GAMMA = 0.01 from (0:1);               // TO BE CHECKED
   (* desc = "Current compression ratio\nReduces transconductance by this factor. Negative value increases tranconductance.                 ", units = "V" *)               // TO BE CHECKED
   parameter real CJ_ALPHA=0.0 from (-1:1);               // TO BE CHECKED
   (* desc = "Current compression position\nThe gate potential at the center of carrier density compression is set to (ALPHA_V*(VBI-VTO)).  " *)               // TO BE CHECKED
   parameter real CJ_ALPHA_V=1.0 from (0:5);               // TO BE CHECKED
   (* desc = "Current compression width\nSets width of the carrier density compression region to approximately (ALPHA_Z*ALSPA_V*(VBI-VTO)). " *)               // TO BE CHECKED
   parameter real CJ_ALPHA_Z=0.5 from (0:1];               // TO BE CHECKED
   (* desc = "Drain-source velocity saturation potential\nProportional to channel length and effective saturation field strength.           ", units = "V" *)               // TO BE CHECKED
   parameter real CJ_XI=1.0 from [0:inf);               // TO BE CHECKED
   (* desc = "Current saturation smoothing parameter\nWidth of transition to saturated velocity mode (from low to high field regions).      ", units = "V" *)               // TO BE CHECKED
   parameter real CJ_XI_SS=0.1 from [0.01:inf);               // TO BE CHECKED
   (* desc = "Width of divide by zero region", units = "V" *)               // TO BE CHECKED
   parameter real CJ_VS   = 1e-12  from (-0.1:0.1);               // TO BE CHECKED
   (* desc = "Saturated region capaciance constribution", units = "F" *)               // TO BE CHECKED
   parameter real CJ_CSAT   = 0.1  from (-inf:inf);               // TO BE CHECKED
   (* desc = "Width of limiting extended pinch-off position at LF_EXTENSION      ", units = "V" *)               // TO BE CHECKED
   parameter real CJ_ZL  = 0.05 from (0:inf);               // TO BE CHECKED
   (* desc = "Width of transition of extended channel region to reverse mode      ", units = "V" *)               // TO BE CHECKED
   parameter real CJ_ZREV  = 0.05 from (0:inf);               // TO BE CHECKED
   (* desc = "Limit of channel extension for source (or drain) end charge region" *)               // TO BE CHECKED
   parameter real CJ_LF_EXTENSION  = 2.0 from (0:inf);               // TO BE CHECKED
   parameter real CJ_LAMBDA  = 500.0 from (0:inf);               // TO BE CHECKED
   (* desc = "Channel-length reduction smoothing\nSets rate w.r.t. drain-source potential of onset of channel length reduction.             ", units = "V" *)               // TO BE CHECKED
   parameter real CJ_LAMBDA_S=0.1 from [0:inf);               // TO BE CHECKED
   parameter real CJ_CDS=0;               // TO BE CHECKED
   parameter real CJ_CDSV=0.2;               // TO BE CHECKED
   

//   (* desc = "Diffusion ccapacitance transit time\nZero for Schottky junctions", units = "s" *)               // TO BE CHECKED
//   parameter real DIODE_TT = 0.0 from [0:inf);               // TO BE CHECKED
//   (* desc = "flicker noise coefficient" *)               // TO BE CHECKED
//   parameter real DIODE_KF = 0.0 from [0:inf);               // TO BE CHECKED
//   (* desc = "flicker noise current exponent" *)               // TO BE CHECKED
//   parameter real DIODE_AF = 1.0 from [0:inf);               // TO BE CHECKED
//   (* desc = "flicker noise frequency exponent" *)               // TO BE CHECKED
//   parameter real DIODE_EF = 1.0 from [0:inf);               // TO BE CHECKED

   (* desc = "Exponential region maximum current\nNominally set to the maximum safe current", units = "A" *)               // TO BE CHECKED
   parameter real DIODE_MAX_CURRENT = 1000.0 from (0.0:inf);               // TO BE CHECKED
   (* desc = "Estimated thermal resistance to ambient.\nUsed to prevent thermal instability point", units = "K/W" *)               // TO BE CHECKED
   parameter real DIODE_RTH = 0;               // TO BE CHECKED

   // /////////////////////////////////////////////////////////////////////// ///////////////////////////////////////////////////////////////////////               // TO BE CHECKED

   // Impact Ionization Parameters               // TO BE CHECKED
   (* desc = "Maximum impact ionization rate\nSets the maximum impact ionization rate at extreme drain potential.                           " *)               // TO BE CHECKED
   parameter real II_A=0.0 from [0:inf);               // TO BE CHECKED
   (* desc = "Impact ionization potential\nSets the rate of impact ionization relative to the drain-source potential and breakdown.         ", units = "V" *)               // TO BE CHECKED
   parameter real II_B=2.0 from [0:inf);               // TO BE CHECKED
   (* desc = "Thermal coefficient of impact ionization potential\nIncrease in II_B with temperature (V/K).                                  " *)               // TO BE CHECKED
   parameter real II_BT=0.0 from (-1000.0/`TEMPERATURE_UPPER_BOUND:1000.0/TNOM);               // TO BE CHECKED
   (* desc = "Minimum impact ionization rate\nSet minimum possible impact ionization rate for numerical stability.                          " *)               // TO BE CHECKED
   parameter real II_D=1.0E-12 from (0:1);               // TO BE CHECKED
   (* desc = "Gate transition probability activation potential\nSets probability that impact ionization current reaches the gate.           ", units = "V" *)               // TO BE CHECKED
   parameter real II_E=1.0 from [0:inf);               // TO BE CHECKED
   (* desc = "Gate transition probability normalizing factor\nSets maximum probability that impact ionization current reaches the gate.     " *)               // TO BE CHECKED
   parameter real II_EO=1.0 from (0:inf);               // TO BE CHECKED
   (* desc = "Avalanche breakdown rate limiting\nReducing this may ameliorate convergence issues during avalanche breakdown.                " *)               // TO BE CHECKED
   parameter real II_N=15.0 from (1:inf);               // TO BE CHECKED
   (* desc = "Potential for onset of impact ionization\nDrain-source saturation potential for onset of impact ionization.                   ", units = "V" *)               // TO BE CHECKED
   parameter real II_V=1.0 from [0:inf);               // TO BE CHECKED
   (* desc = "Transition width of onset of impact ionization\nRate of initial growth of impact ionization rate relative to drain potential. ", units = "V" *)               // TO BE CHECKED
   parameter real II_Z=0.2 from [0:inf);               // TO BE CHECKED


   // /////////////////////////////////////////////////////////////////////// /////////////////////////////////////////////////////////////////////// ///////////////////////////////////////////////////////////////////////

    ////////  //    //   //     //    //////    ////////   //    //////    //     //    //////
    //        //    //   ///    //   //    //      //      //   //    //   ///    //   //
    //////    //    //   // /   //   //            //      //   //    //   // /   //    /////
    //        //    //   //  /  //   //            //      //   //    //   //  /  //        //
    //        //    //   //   / //   //    //      //      //   //    //   //   / //   /    //
    //         //////    //    ///    //////       //      //    //////    //    ///    /////


    analog function real Smooth_Min_times2;               // TO BE CHECKED
        // Returns twice (x bounded to upper limit).               // TO BE CHECKED
        // At (x = upper limit), the returned value is 2*(x - radius)               // TO BE CHECKED
        input x, upper_limit, radius_squared_times4;               // TO BE CHECKED
        real  x, upper_limit, radius_squared_times4;               // TO BE CHECKED
        real tmp;               // TO BE CHECKED
        begin               // TO BE CHECKED
            tmp = x - upper_limit;               // TO BE CHECKED
            Smooth_Min_times2 = x + upper_limit - sqrt(tmp * tmp + radius_squared_times4);               // TO BE CHECKED
        end               // TO BE CHECKED
    endfunction // Smooth_Min_times2               // TO BE CHECKED


    analog function real Smooth_Max_times2;               // TO BE CHECKED
        // Returns twice (x bounded to lower limit).               // TO BE CHECKED
        // At (x = lower limit), the returned value is 2*(x + radius)               // TO BE CHECKED
        input x, lower_limit, radius_squared_times4;               // TO BE CHECKED
        real  x, lower_limit, radius_squared_times4;               // TO BE CHECKED
        real tmp;               // TO BE CHECKED
        begin               // TO BE CHECKED
            tmp = x - lower_limit;               // TO BE CHECKED
            Smooth_Max_times2 = x + lower_limit + sqrt(tmp * tmp + radius_squared_times4);               // TO BE CHECKED
        end               // TO BE CHECKED
    endfunction // Smooth_Max_times2               // TO BE CHECKED


    analog function real Soft_ABS;               // TO BE CHECKED
       input x, radius_squared;               // TO BE CHECKED
           real  x, radius_squared;               // TO BE CHECKED
           Soft_ABS = sqrt(x * x + radius_squared);               // TO BE CHECKED
    endfunction //Soft_ABS               // TO BE CHECKED


    analog function real DiodeEXP;               // TO BE CHECKED
        // Bounded diode model expression.               // TO BE CHECKED
        // exp_M is nominal set to the ratio MAX_CURRENT/SCALE and must be (0:inf)               // TO BE CHECKED
        // M is set to ln(exp_M) outside this function to reduce computation effort               // TO BE CHECKED
        // The bias and activation factors are qv/nkT and qEa/kt respectively               // TO BE CHECKED
        input BiasFactor, ActivationFactor, M, exp_M;               // TO BE CHECKED
        real  BiasFactor, ActivationFactor, M, exp_M;               // TO BE CHECKED
        real leakage, sum;               // TO BE CHECKED
        begin               // TO BE CHECKED
            if (ActivationFactor > M )               // TO BE CHECKED
                leakage =   exp_M * (1.0 + ActivationFactor - M);               // TO BE CHECKED
            else               // TO BE CHECKED
                if (ActivationFactor > -M)               // TO BE CHECKED
                    leakage = exp(ActivationFactor);               // TO BE CHECKED
                else               // TO BE CHECKED
                    leakage = 1.0 / exp_M / (1.0 - ActivationFactor - M);               // TO BE CHECKED
               // TO BE CHECKED
            sum = ActivationFactor + BiasFactor;               // TO BE CHECKED
            if (sum > M )               // TO BE CHECKED
                DiodeEXP =   exp_M * (1.0 + sum - M) - leakage;               // TO BE CHECKED
            else               // TO BE CHECKED
                if (sum > -M)               // TO BE CHECKED
                    DiodeEXP = exp(sum) - leakage;               // TO BE CHECKED
                else               // TO BE CHECKED
                    DiodeEXP = 1.0 / exp_M / (1.0 - sum - M) - leakage;               // TO BE CHECKED
        end               // TO BE CHECKED
    endfunction //DiodeEXP               // TO BE CHECKED


    //  A macro is used to calculate ln(exp(x)+1) to prevent numerical overflow.               // TO BE CHECKED
    //  GM = 1.0e-5 is Minimum conductance:               // TO BE CHECKED
    //     not too small else there is fatal rounding error in pow(v-v, P)               // TO BE CHECKED
    analog function real lne;               // TO BE CHECKED
       `define LN_GM           -11.512925464970229       /* log(GM) */               // TO BE CHECKED
       `define NEG_LN_GM        11.512925464970229       /* -log(GM) */               // TO BE CHECKED
       `define LN_GMPLUS1       0.0000099999500003988414 /* log(GM+1) */               // TO BE CHECKED
       `define LN_GMOVERGMPLUS1 0.99999500003511532      /* GM/(GM+1)/LN_GMPLUS1 */               // TO BE CHECKED
        input x;               // TO BE CHECKED
        real x;               // TO BE CHECKED
        begin               // TO BE CHECKED
            if (x > `NEG_LN_GM)               // TO BE CHECKED
                lne = `LN_GMPLUS1/(1.0 + `LN_GMOVERGMPLUS1*(x + `LN_GM))+ x;               // TO BE CHECKED
            else               // TO BE CHECKED
                if (x > `LN_GM)               // TO BE CHECKED
                    lne = ln(1 + exp(x));               // TO BE CHECKED
                else               // TO BE CHECKED
                    lne = `LN_GMPLUS1/(1.0 - `LN_GMOVERGMPLUS1 * (x + `LN_GM));               // TO BE CHECKED
        end               // TO BE CHECKED
    endfunction //lne               // TO BE CHECKED


    analog function real lne_derivative;               // TO BE CHECKED
       `define GMOVERGMPLUS1 0.00000999990000099999 /* GM/(GM+1) */               // TO BE CHECKED
        input x;               // TO BE CHECKED
        real x;               // TO BE CHECKED
        real tmp;               // TO BE CHECKED
        begin               // TO BE CHECKED
            if (x > `NEG_LN_GM)               // TO BE CHECKED
                begin               // TO BE CHECKED
                    tmp = 1.0 + `LN_GMOVERGMPLUS1 * ( x + `LN_GM );               // TO BE CHECKED
                    lne_derivative = 1.0 - `GMOVERGMPLUS1 / ( tmp * tmp );               // TO BE CHECKED
                end               // TO BE CHECKED
            else               // TO BE CHECKED
                if (x > `LN_GM)               // TO BE CHECKED
                    lne_derivative = 1.0 / (1.0 + exp(-x));               // TO BE CHECKED
                else               // TO BE CHECKED
                    begin               // TO BE CHECKED
                        tmp = 1.0 - `LN_GMOVERGMPLUS1 * ( x + `LN_GM );               // TO BE CHECKED
                        lne_derivative = `GMOVERGMPLUS1 / ( tmp * tmp );               // TO BE CHECKED
                    end               // TO BE CHECKED
        end               // TO BE CHECKED
    endfunction //lne_derivative               // TO BE CHECKED


    analog function real skip_zero;               // TO BE CHECKED
        input x, d;               // TO BE CHECKED
        real x, d;               // TO BE CHECKED
        begin               // TO BE CHECKED
            if (abs(x) > d) 
                skip_zero = x;
            else
                if (x > 0) 
                    skip_zero = d;
                else
                    skip_zero = -d;
        end
    endfunction //lne_derivative               // TO BE CHECKED


    // /////////////////////////////////////////////////////////////////////// /////////////////////////////////////////////////////////////////////// ///////////////////////////////////////////////////////////////////////
    analog begin
         real    vgs_plus_vtrap,            vgd_plus_vtrap;
         real    Channel_Current_GS,        Channel_Current_GD;
         real    Enhancement_Potential_GS,  Enhancement_Potential_GD;
         real    Enhancement_Factor_GS,     Enhancement_Factor_GD;

        // /////////////////////////////////////////////////////////////////////// /////////////////////////////////////////////////////////////////////// ///////////////////////////////////////////////////////////////////
        // variables               // TO BE CHECKED
        real Tjunction_upper_bounded_times2, bounded_Tjunction_times4;               // TO BE CHECKED

        // Gate Junction variables               // TO BE CHECKED
        real     _ENHANCEMENT_POLARITY;
        real     Diode_GS_Fwd_Current, Diode_GS_Rev_Current;               // TO BE CHECKED
        real     Diode_GD_Fwd_Current, Diode_GD_Rev_Current;               // TO BE CHECKED
        real     Diode_GS_Fwd_Pwr_Scale, Diode_GS_Rev_Pwr_Scale;               // TO BE CHECKED
        real     Diode_GD_Fwd_Pwr_Scale, Diode_GD_Rev_Pwr_Scale;               // TO BE CHECKED
        real     Diode_GS_Charge, Diode_GD_Charge;               // TO BE CHECKED

        // /////////////////////////////////////////////////////////////////////// ///////////////////////////////////////////////////////////////////////               // TO BE CHECKED
        // Instance Parameters

        real     _VELOCITY_TRANSITION_T_times2, _VELOCITY_TRANSITION_T_squared_times4;               // TO BE CHECKED
        real     _VELOCITY_OFFSET, _VELCOCITY_TEMP_COEEFICIENT_times4;               // TO BE CHECKED
        real     _BOUNDED_TNOM_times4;               // TO BE CHECKED
        real     _DEPLETION_POTENTIAL, _DEPLETION_POTENTIAL_squared_over100, _GAMMA_FACTORover2;               // TO BE CHECKED

        real     _C_DEPLETION_POTENTIAL, _C_DEPLETION_POTENTIAL_squared_over100, _C_GAMMA_FACTORover2;               // TO BE CHECKED

        real     _DIODE_FWD_1overVT, _DIODE_FWD_ActivationFactor, _DIODE_FWD_EXP_M, _DIODE_FWD_M, _DIODE_FWD_ISAT;               // TO BE CHECKED
        real     _DIODE_REV_1overVB, _DIODE_REV_ActivationFactor, _DIODE_REV_EXP_M, _DIODE_REV_M, _DIODE_REV_ISAT;               // TO BE CHECKED
        real     _DIODE_OFFSET;               // TO BE CHECKED
        real     _DIODE_TURNING_POTENTIAL, _DIODE_TURNING_WIDTH_SQUARED, _DIODE_TURNING_FACTOR_RATIO;               // TO BE CHECKED
        real     _DIODE_CHARGE_SCALE;               // TO BE CHECKED
        real     _COLD_SIGMA, _SIGMA_WARMINGover4;               // TO BE CHECKED
        real     _DIODE_DEPLETION_INDEXminus1;               // TO BE CHECKED
        real     _DIODE_RTH_times_ENHANCEMENT_POLARITY;                        // TO BE CHECKED

        real     _COLD_VST, _VST_WARMINGover4, _C_COLD_PINCH_OFF, _COLD_PINCH_OFF, _PINCH_OFF_WARMINGover4;

        real     _GM_TURNING_FACTOR_RATIO, _GM_TURNING_POTENTIAL, _GM_TURNING_POTENTIAL_times2, _GM_TURNING_POTENTIAL_plus_XI;               // TO BE CHECKED
        real     _GM_TURNING_POTENTIAL_over_XI, _GM_TURNING_WIDTH_SQUARED, _GM_TURNING_WIDTH_SQUARED_times4, _GM_OFFSET, _GM_OFFSET_times2;               // TO BE CHECKED

        real     _3over4plusP, _6over4plusP, _6XIover4plusP, _1plusPover4plusP_times2;               // TO BE CHECKED
        real     _XI_X_factor, _XI_X_squared, _XI_SS_squared;               // TO BE CHECKED
        integer  _XI_X_near1;                         // TO BE CHECKED

        real     _C_GM_TURNING_FACTOR_RATIO, _C_GM_TURNING_POTENTIAL, _C_GM_TURNING_POTENTIAL_times2, _C_GM_TURNING_POTENTIAL_plus_XI;               // TO BE CHECKED
        real     _C_GM_TURNING_POTENTIAL_over_XI, _C_GM_TURNING_WIDTH_SQUARED, _C_GM_TURNING_WIDTH_SQUARED_times4, _C_GM_OFFSET, _C_GM_OFFSET_times2;               // TO BE CHECKED

        real     _C_3over4plusP, _C_6over4plusP, _C_6XIover4plusP, _C_1plusPover4plusP_times2;               // TO BE CHECKED
        real     _C_XI_X_factor;                         // TO BE CHECKED

        real     _LAMBDA_over_LAMBDA_S, _XI_times_LAMBDA_over_LAMBDA_S_times2, _XI_times_XI_MU_times2, _XI_times_XI_MU_squared_times4;               // TO BE CHECKED
        real     _C_LAMBDA_over_LAMBDA_S;
        
        real     _DRAIN_CURRENT_SCALE;               // TO BE CHECKED

        real     _IMPACT_IONIZATION_SCALE, _II_OFFSET, _II_OFFSETtimes2, _II_Z_squared, _II_B_TEMP_COEF_over2, _II_COLD_B_times2, _E_over_lnD, _D_times_E_over_lnD_over_lnD, _E_over_lnD_over_lnD_minus_EoverlnD;

        real QDS;
        // /////////////////////////////////////////////////////////////////////// /////////////////////////////////////////////////////////////////////// ///////////////////////////////////////////////////////////////////
        // All constant terms are calculated ahead of the time in the set up procedure. These precalculated terms have               // TO BE CHECKED
        // upper case identifiers preceded by an underscore and may have a trailing multiplicative digit if one applies.               // TO BE CHECKED
        @(initial_step) begin

             // local variables
             real Tnom_upper_bounded_times2, Velocity_Temperature_Denominator;
             real Inverse_Junction_Thermal_Potential;               // TO BE CHECKED
             real Turning_Width, Turning_Primitive;               // TO BE CHECKED
             real Sigma_Temp_Coef, Sigma_Temp_Coefficient_limit;               // TO BE CHECKED
             real Normalisation_Factor;
             real offset, lnD,  E_over_lnD_over_lnD;

             // polarity of the channel determined by sign of the channel depletion potential (VBI-VTO)
             if (VBI > VTO)
                     _ENHANCEMENT_POLARITY = +1.0;  // n-channel
             else
                     _ENHANCEMENT_POLARITY = -1.0;  // p-channel

             // Temperature Mapping : Bounds on Temperature are imposed for numerical stability. The same bounds are applied to TNOM, so that the relationship between instance temperature and TNOM is maintained.
             Tnom_upper_bounded_times2 = Smooth_Min_times2(TNOM,                      `TEMPERATURE_UPPER_BOUND,        `TEMP_UPPER_BOUND_RADIUS_SQR_times4 );
             _BOUNDED_TNOM_times4      = Smooth_Max_times2(Tnom_upper_bounded_times2, `TEMPERATURE_LOWER_BOUND_times2, `TEMP_LOWER_BOUND_RADIUS_SQR_times16);

             // /////////////////////////////////////////////////////////////////////// /////////////////////////////////////////////////////////////////////// ///////////////////////////////////////////////////////////////

             // Diode Junction Instance Parameters
             Inverse_Junction_Thermal_Potential    = `QoverK / TNOM;               // TO BE CHECKED
             _DIODE_RTH_times_ENHANCEMENT_POLARITY =  DIODE_RTH * _ENHANCEMENT_POLARITY;
             _DIODE_FWD_1overVT                    =  _ENHANCEMENT_POLARITY * Inverse_Junction_Thermal_Potential / DIODE_FWD_N;               // TO BE CHECKED
             _DIODE_REV_1overVB                    =  -_ENHANCEMENT_POLARITY / DIODE_REV_V;               // TO BE CHECKED
               // TO BE CHECKED
             _DIODE_FWD_ActivationFactor           =  -DIODE_FWD_EG * Inverse_Junction_Thermal_Potential;               // TO BE CHECKED
             _DIODE_REV_ActivationFactor           =  -DIODE_REV_EG * Inverse_Junction_Thermal_Potential;               // TO BE CHECKED

             // exp_M is bounded here to > MAX_CURRENT times `NEAR_ZERO to permit zero scales without divide by zero               // TO BE CHECKED
             _DIODE_FWD_EXP_M                      =  DIODE_MAX_CURRENT / (DIODE_FWD_SCALE + `CURRENT_ABSTOL);               // TO BE CHECKED
             _DIODE_REV_EXP_M                      =  DIODE_MAX_CURRENT / (DIODE_REV_SCALE + `CURRENT_ABSTOL);               // TO BE CHECKED
               // TO BE CHECKED
             _DIODE_FWD_M                          =  ln(_DIODE_FWD_EXP_M);               // TO BE CHECKED
             _DIODE_REV_M                          =  ln(_DIODE_REV_EXP_M);               // TO BE CHECKED
               // TO BE CHECKED
             _DIODE_FWD_ISAT                       =  +_ENHANCEMENT_POLARITY * DIODE_FWD_SCALE * exp(-_DIODE_FWD_ActivationFactor);               // TO BE CHECKED
             _DIODE_REV_ISAT                       =  -_ENHANCEMENT_POLARITY * DIODE_REV_SCALE * exp(-_DIODE_REV_ActivationFactor);               // TO BE CHECKED

             // /////////////////////////////////////////////////////////////////////// ///////////////////////////////////////////////////////////////////////               // TO BE CHECKED
//             // Diode Depletion Charge Instance Parameters               // TO BE CHECKED
//             _DIODE_TURNING_FACTOR_RATIO   = abs(DIODE_TURNING_FACTOR) > 0.01 ? DIODE_TURNING_FACTOR / (2.0 - DIODE_TURNING_FACTOR) : 0.0;               // TO BE CHECKED
//             _DIODE_TURNING_POTENTIAL      = DIODE_TURNING_POSITION * ( DIODE_BARRIER_HEIGHT - DIODE_PINCH_OFF - _BOUNDED_TNOM_times4 * `KoverQover4 );               // TO BE CHECKED
//             Turning_Width                 = _DIODE_TURNING_FACTOR_RATIO ? DIODE_TURNING_RADIUS * _DIODE_TURNING_POTENTIAL / abs(DIODE_TURNING_FACTOR) : 1.0;               // TO BE CHECKED
//             _DIODE_TURNING_WIDTH_SQUARED  = Turning_Width * Turning_Width;               // TO BE CHECKED
//             _DIODE_OFFSET                 = Soft_ABS( _DIODE_TURNING_POTENTIAL , _DIODE_TURNING_WIDTH_SQUARED );               // TO BE CHECKED
//             Turning_Primitive             = _DIODE_TURNING_POTENTIAL + _DIODE_TURNING_FACTOR_RATIO * (_DIODE_OFFSET - Turning_Width);               // TO BE CHECKED
//             _DIODE_DEPLETION_INDEXminus1  = DIODE_DEPLETION_INDEX - 1.0;               // TO BE CHECKED
//             _DIODE_CHARGE_SCALE           = DIODE_DEPLETION_CAPACITANCE * pow(Turning_Primitive, 2.0 - DIODE_DEPLETION_INDEX)               // TO BE CHECKED
//                                                         / ( _DIODE_DEPLETION_INDEXminus1 - _DIODE_TURNING_FACTOR_RATIO * Turning_Primitive / Turning_Width );               // TO BE CHECKED

             // /////////////////////////////////////////////////////////////////////// /////////////////////////////////////////////////////////////////////// ////////////////////////////////////////////////////////////////
             // Drain-Source Current Instance Parameters

             // Channel depletion potential, pinch-off, and drain feedback parameter
             _PINCH_OFF_WARMINGover4               = (VBI_T - 1.0) * `KoverQover4;
             if ( _ENHANCEMENT_POLARITY > 0.0 )  // n-channel
                 begin
                     _DEPLETION_POTENTIAL          = VBI - VTO - _BOUNDED_TNOM_times4 * `KoverQover4;
                     _C_DEPLETION_POTENTIAL        = CJ_VBI - CJ_PINCH_OFF - _BOUNDED_TNOM_times4 * `KoverQover4;
                     _COLD_PINCH_OFF               = VTO - _PINCH_OFF_WARMINGover4 * _BOUNDED_TNOM_times4;
                     _C_COLD_PINCH_OFF             = CJ_PINCH_OFF - _PINCH_OFF_WARMINGover4 * _BOUNDED_TNOM_times4;
                     _GAMMA_FACTORover2            = 0.5 * GAMMA / (_DEPLETION_POTENTIAL + VBI * GAMMA);
                     _C_GAMMA_FACTORover2          = 0.5 * CJ_GAMMA / (_C_DEPLETION_POTENTIAL + CJ_VBI * CJ_GAMMA); 
                 end
             else // p-channel
                 begin
                     _DEPLETION_POTENTIAL          = VTO - VBI - _BOUNDED_TNOM_times4 * `KoverQover4;
                     _C_DEPLETION_POTENTIAL        = CJ_PINCH_OFF - CJ_VBI - _BOUNDED_TNOM_times4 * `KoverQover4;
                     _COLD_PINCH_OFF               = -VTO - _PINCH_OFF_WARMINGover4 * _BOUNDED_TNOM_times4;
                     _C_COLD_PINCH_OFF             = -CJ_PINCH_OFF - _PINCH_OFF_WARMINGover4 * _BOUNDED_TNOM_times4;
                     _GAMMA_FACTORover2            = 0.5 * GAMMA / (_DEPLETION_POTENTIAL - VBI * GAMMA);
                     _C_GAMMA_FACTORover2          = 0.5 * CJ_GAMMA / (_C_DEPLETION_POTENTIAL - CJ_VBI * CJ_GAMMA); 
                 end
            _DEPLETION_POTENTIAL_squared_over100   = _DEPLETION_POTENTIAL * _DEPLETION_POTENTIAL / 100.0;

             // soft pinch-off parameters
             Sigma_Temp_Coefficient_limit          =  VST * P * `QoverK / (TNOM - `TEMPERATURE_UPPER_BOUND);
             Sigma_Temp_Coef                       =  VST_T > Sigma_Temp_Coefficient_limit ? VST_T : Sigma_Temp_Coefficient_limit;
             Sigma_Temp_Coefficient_limit          =  VST * P * `QoverK / (TNOM - `TEMPERATURE_LOWER_BOUND_times2);
             _SIGMA_WARMINGover4                   =  (Sigma_Temp_Coef < Sigma_Temp_Coefficient_limit ? Sigma_Temp_Coef : Sigma_Temp_Coefficient_limit) * `KoverQover4 / P;
             _COLD_SIGMA                           =  VST - _BOUNDED_TNOM_times4 * _SIGMA_WARMINGover4;

            // Carrier density compression parameters
            _GM_TURNING_FACTOR_RATIO               =  abs(ALPHA) > 0.01 ? ALPHA / (2.0 - ALPHA) : 0.0;
            _GM_TURNING_POTENTIAL                  =  ALPHA_V * _DEPLETION_POTENTIAL;
            _GM_TURNING_POTENTIAL_times2           =  _GM_TURNING_POTENTIAL + _GM_TURNING_POTENTIAL;
            _GM_TURNING_POTENTIAL_plus_XI          =  _GM_TURNING_POTENTIAL + XI;
            _GM_TURNING_POTENTIAL_over_XI          =  _GM_TURNING_POTENTIAL / XI;
            Turning_Width                          =  _GM_TURNING_FACTOR_RATIO ? ALPHA_Z * _GM_TURNING_POTENTIAL / abs(ALPHA) : 1.0;
            _GM_TURNING_WIDTH_SQUARED              =  Turning_Width * Turning_Width;
            _GM_TURNING_WIDTH_SQUARED_times4       =  4.0 * _GM_TURNING_WIDTH_SQUARED;
            _GM_OFFSET                             =  Soft_ABS( _GM_TURNING_POTENTIAL , _GM_TURNING_WIDTH_SQUARED );
            _GM_OFFSET_times2                      =  _GM_OFFSET + _GM_OFFSET;


            _C_GM_TURNING_FACTOR_RATIO             =  abs(CJ_ALPHA) > 0.01 ? CJ_ALPHA / (2.0 - CJ_ALPHA) : 0.0;
            _C_GM_TURNING_POTENTIAL                =  CJ_ALPHA_V * _C_DEPLETION_POTENTIAL;
            _C_GM_TURNING_POTENTIAL_times2         =  _C_GM_TURNING_POTENTIAL + _C_GM_TURNING_POTENTIAL;
            _C_GM_TURNING_POTENTIAL_plus_XI        =  _C_GM_TURNING_POTENTIAL + CJ_XI;
            _C_GM_TURNING_POTENTIAL_over_XI        =  _C_GM_TURNING_POTENTIAL / CJ_XI;
            Turning_Width                          =  _C_GM_TURNING_FACTOR_RATIO ? CJ_ALPHA_Z * _C_GM_TURNING_POTENTIAL / abs(CJ_ALPHA) : 1.0;
            _C_GM_TURNING_WIDTH_SQUARED            =  Turning_Width * Turning_Width;
            _C_GM_TURNING_WIDTH_SQUARED_times4     =  4.0 * _C_GM_TURNING_WIDTH_SQUARED;
            _C_GM_OFFSET                           =  Soft_ABS( _C_GM_TURNING_POTENTIAL , _C_GM_TURNING_WIDTH_SQUARED );
            _C_GM_OFFSET_times2                    =  _C_GM_OFFSET + _C_GM_OFFSET;



            // Velocity saturation parameters
            _XI_X_near1                            =  abs(XI_X - 1.0) < 0.01;
            _3over4plusP                           =  3.0 / (4.0 + P);
            _6over4plusP                           =  _3over4plusP + _3over4plusP;
            _6XIover4plusP                         =  XI * _6over4plusP;
            _1plusPover4plusP_times2               =  2.0 * (1.0 + P) / (4.0 + P);
            _XI_X_factor                           =  _XI_X_near1 ? 0.0 : XI / (1.0 - XI_X);
            _XI_X_squared                          =  XI_X * XI_X;
            _XI_SS_squared                         =  XI_SS * XI_SS;

            _C_3over4plusP                           =  3.0 / (4.0 + CJ_P);
            _C_6over4plusP                           =  _C_3over4plusP + _C_3over4plusP;
            _C_6XIover4plusP                         =  CJ_XI * _C_6over4plusP;    /* AEP version 22 added _C*/
            _C_1plusPover4plusP_times2               =  2.0 * (1.0 + CJ_P) / (4.0 + CJ_P);
            _C_XI_X_factor                           =  _XI_X_near1 ? 0.0 : CJ_XI / (1.0 - XI_X);

            // Channel conductance parameters
            Normalisation_Factor                   =  pow(2.0 * (_DEPLETION_POTENTIAL - _GM_TURNING_FACTOR_RATIO * (Soft_ABS(_DEPLETION_POTENTIAL - _GM_TURNING_POTENTIAL, _GM_TURNING_WIDTH_SQUARED) - _GM_OFFSET) ), P);
            _DRAIN_CURRENT_SCALE                   =  _ENHANCEMENT_POLARITY * 2.0 * BETA * XI * _DEPLETION_POTENTIAL / ( P * Normalisation_Factor );

            // A separate temperature mapping is applied to account for temperature dependence of electron velocity. This is normalized to the nominal temperature of extraction, TNOM by the denominator.
            _VELOCITY_TRANSITION_T_times2          =  BETA_TT * 0.933333333333333; // Slightly less than (14/15) transition temperature
            _VELOCITY_TRANSITION_T_squared_times4  =  _VELOCITY_TRANSITION_T_times2 * _VELOCITY_TRANSITION_T_times2;
            Velocity_Temperature_Denominator       =  1.0 - BETA_TL * (1 - 4.0 * BETA_TT / Smooth_Max_times2( TNOM + TNOM, _VELOCITY_TRANSITION_T_times2, _VELOCITY_TRANSITION_T_squared_times4) );
            _VELOCITY_OFFSET                       =  (1.0 - BETA_TL) / Velocity_Temperature_Denominator;
            _VELCOCITY_TEMP_COEEFICIENT_times4     =  4.0 * BETA_TL * BETA_TT / Velocity_Temperature_Denominator;

            // channel length modulation parameters
            _LAMBDA_over_LAMBDA_S                  =  LAMBDA / LAMBDA_S;
            _XI_times_LAMBDA_over_LAMBDA_S_times2  =  _LAMBDA_over_LAMBDA_S * XI * 2.0;
            _XI_times_XI_MU_times2                 =  2.0 * XI_MU * XI;
            _XI_times_XI_MU_squared_times4         =  _XI_times_XI_MU_times2 * _XI_times_XI_MU_times2;


            _C_LAMBDA_over_LAMBDA_S                =  CJ_LAMBDA / CJ_LAMBDA_S;

            // Impact Ionization parameters
            _II_B_TEMP_COEF_over2                  =  0.0005 * II_B * II_BT;
            _II_COLD_B_times2                      =  II_B + II_B - _II_B_TEMP_COEF_over2 * _BOUNDED_TNOM_times4;
            _IMPACT_IONIZATION_SCALE               =  II_N * sqrt( 2.0 * Normalisation_Factor );
            lnD                                    =  ln(II_D);
            offset                                 =  (II_A > II_D) ? II_B / ( lnD - ln(II_A) ) : 0.0;
            _II_Z_squared                          =  II_Z * II_Z;
            _II_OFFSET                             =  II_V + offset;
            _II_OFFSETtimes2                       =  2.0 * ( Soft_ABS(_II_OFFSET, _II_Z_squared) + offset );
            _E_over_lnD                            =  II_E / lnD;
            E_over_lnD_over_lnD                    =  _E_over_lnD / lnD;
            _D_times_E_over_lnD_over_lnD           =  E_over_lnD_over_lnD * II_D;
            _E_over_lnD_over_lnD_minus_EoverlnD    =  E_over_lnD_over_lnD - _E_over_lnD;

        end //initialize

        // /////////////////////////////////////////////////////////////////////// /////////////////////////////////////////////////////////////////////// ///////////////////////////////////////////////////////////////////

        // Temperature Mapping : Bounds on Temperature are imposed for numerical stability. This is the same bounding that was applied to TNOM, so that the relationship between instance temperature and TNOM is maintained.

        Tjunction_upper_bounded_times2 = Smooth_Min_times2(Temp(Tj) * `kKelvin + `P_CELSIUS0 , `TEMPERATURE_UPPER_BOUND, `TEMP_UPPER_BOUND_RADIUS_SQR_times4);

        bounded_Tjunction_times4 = Smooth_Max_times2(Tjunction_upper_bounded_times2, `TEMPERATURE_LOWER_BOUND_times2, `TEMP_LOWER_BOUND_RADIUS_SQR_times16);

        // /////////////////////////////////////////////////////////////////////// /////////////////////////////////////////////////////////////////////// ///////////////////////////////////////////////////////////////////
        
        begin // { Determine Channel_Current_GS and Channel_Current_GD, Enhancement_Factor_GS, Enhancement_Factor_GD, Enhancement_Potential_GS and Enhancement_Potential_GD
            real     ids, vds;
            real     LowField_Saturation_Potential_XS,  Saturated_Enhancement_Potential_GS_times2,  Carrier_Density_Primitive_GS_times4;
            real     LowField_Saturation_Potential_XD,  Saturated_Enhancement_Potential_GD_times2,  Carrier_Density_Primitive_GD_times4;


            //channel current ids corresponds to vds. Both ids and vds are +ve when the drain end is the more depleted (higher field) end
            vds                                           =  _ENHANCEMENT_POLARITY * ( V(g,s) - V(g,d) );
            vgs_plus_vtrap                                =  _ENHANCEMENT_POLARITY * ( V(g,s) + V(Trap_Potential) );
            vgd_plus_vtrap                                =  _ENHANCEMENT_POLARITY * ( V(g,d) + V(Trap_Potential) );


            begin // { Determine the Enhancement_Potential_GS and Enhancement_Potential_GD
                real     Pinchoff_Potential, Sigma, Drain_Feedback_Potential;

                Pinchoff_Potential                        =  _COLD_PINCH_OFF + bounded_Tjunction_times4 * _PINCH_OFF_WARMINGover4;
                Sigma                                     =  _COLD_SIGMA     + bounded_Tjunction_times4 * _SIGMA_WARMINGover4;
                Drain_Feedback_Potential                  =  vds * GAMMA;

                Enhancement_Factor_GS                     = (vgs_plus_vtrap + Drain_Feedback_Potential - Pinchoff_Potential)
                                                                      / ( Sigma - Sigma * _GAMMA_FACTORover2 * Smooth_Min_times2(vgd_plus_vtrap, _DEPLETION_POTENTIAL, _DEPLETION_POTENTIAL_squared_over100) );
                Enhancement_Potential_GS                  = Sigma * lne(Enhancement_Factor_GS);

                Enhancement_Factor_GD                     = (vgd_plus_vtrap - Drain_Feedback_Potential - Pinchoff_Potential)
                                                                      / ( Sigma - Sigma * _GAMMA_FACTORover2 * Smooth_Min_times2(vgs_plus_vtrap, _DEPLETION_POTENTIAL, _DEPLETION_POTENTIAL_squared_over100) );
                Enhancement_Potential_GD                  = Sigma * lne(Enhancement_Factor_GD);

            end // determination of Enhancement_Potential_GS and Enhancement_Potential_GD }


            begin // { determination of LowField_Saturation_Potential_XS and LowField_Saturation_Potential_XD : End to end potential of low-field region -- equivalent to a vds of the low-field region where drain is at X
                real vgsu, vgdu;
                real Abs_Potential_from_GMPeak, Potential_from_GMPeak;

                // reduced arguments : vgsu, vgdu
                if ( _GM_TURNING_FACTOR_RATIO )
                    begin
                        Potential_from_GMPeak             = Enhancement_Potential_GS - _GM_TURNING_POTENTIAL;
                        Abs_Potential_from_GMPeak         = Soft_ABS(Potential_from_GMPeak, _GM_TURNING_WIDTH_SQUARED);
                        vgsu                              = ( Enhancement_Potential_GS + _GM_TURNING_POTENTIAL_over_XI * ( Enhancement_Potential_GS  + _GM_TURNING_FACTOR_RATIO * (_GM_OFFSET - Abs_Potential_from_GMPeak) )
                                                                                           * Abs_Potential_from_GMPeak / ( Abs_Potential_from_GMPeak - _GM_TURNING_FACTOR_RATIO * Potential_from_GMPeak                    )
                                                             ) / _GM_TURNING_POTENTIAL_plus_XI;

                        Potential_from_GMPeak             = Enhancement_Potential_GD - _GM_TURNING_POTENTIAL;
                        Abs_Potential_from_GMPeak         = Soft_ABS(Potential_from_GMPeak, _GM_TURNING_WIDTH_SQUARED);
                        vgdu                              = ( Enhancement_Potential_GD + _GM_TURNING_POTENTIAL_over_XI * ( Enhancement_Potential_GD  + _GM_TURNING_FACTOR_RATIO * (_GM_OFFSET - Abs_Potential_from_GMPeak) )
                                                                                           * Abs_Potential_from_GMPeak / ( Abs_Potential_from_GMPeak - _GM_TURNING_FACTOR_RATIO * Potential_from_GMPeak                    )
                                                             ) / _GM_TURNING_POTENTIAL_plus_XI;
                    end
                else
                    begin
                        vgsu                              = Enhancement_Potential_GS / XI;
                        vgdu                              = Enhancement_Potential_GD / XI;
                    end

                // potential calculation : LowField_Saturation_Potential_XS and LowField_Saturation_Potential_XD
                if ( _XI_X_near1 )
                    begin
                        LowField_Saturation_Potential_XS  = _6XIover4plusP * vgsu / pow( 1.0 + vgsu, _1plusPover4plusP_times2 );
                        LowField_Saturation_Potential_XD  = _6XIover4plusP * vgdu / pow( 1.0 + vgdu, _1plusPover4plusP_times2 );
                    end
                else
                    begin
                        LowField_Saturation_Potential_XS  = _XI_X_factor * ( pow( 1.0 + vgsu * (2.0 + _XI_X_squared * vgsu), _3over4plusP ) - pow( 1.0 + XI_X * vgsu, _6over4plusP ) );
                        LowField_Saturation_Potential_XD  = _XI_X_factor * ( pow( 1.0 + vgdu * (2.0 + _XI_X_squared * vgdu), _3over4plusP ) - pow( 1.0 + XI_X * vgdu, _6over4plusP ) );
                    end

            end // determination of LowField_Saturation_Potential_XS and LowField_Saturation_Potential_XD }


            begin // { Minimum potentials at end of low-field region of the channel : Saturated_Enhancement_Potential_GS_times2 and Saturated_Enhancement_Potential_GD_times2
                real   Saturation_Potential_GX;

                Saturation_Potential_GX                   = Enhancement_Potential_GD - LowField_Saturation_Potential_XD;
                Saturated_Enhancement_Potential_GS_times2 = Smooth_Max_times2( Enhancement_Potential_GS,  Saturation_Potential_GX, _XI_SS_squared);

                Saturation_Potential_GX                   = Enhancement_Potential_GS - LowField_Saturation_Potential_XS;
                Saturated_Enhancement_Potential_GD_times2 = Smooth_Max_times2( Enhancement_Potential_GD,  Saturation_Potential_GX, _XI_SS_squared);

            end // determination of Saturated_Enhancement_Potential_GS_times2 and Saturated_Enhancement_Potential_GD_times2 }


            begin // { Carrier density primitives

                if ( _GM_TURNING_FACTOR_RATIO )
                   begin
                      Carrier_Density_Primitive_GS_times4 = pow(Saturated_Enhancement_Potential_GS_times2 - _GM_TURNING_FACTOR_RATIO 
                                                                   * ( Soft_ABS(Saturated_Enhancement_Potential_GS_times2 - _GM_TURNING_POTENTIAL_times2, _GM_TURNING_WIDTH_SQUARED_times4) - _GM_OFFSET_times2), P);
                      Carrier_Density_Primitive_GD_times4 = pow(Saturated_Enhancement_Potential_GD_times2 - _GM_TURNING_FACTOR_RATIO
                                                                   * ( Soft_ABS(Saturated_Enhancement_Potential_GD_times2 - _GM_TURNING_POTENTIAL_times2, _GM_TURNING_WIDTH_SQUARED_times4) - _GM_OFFSET_times2), P);
                   end
                else
                   begin
                      Carrier_Density_Primitive_GS_times4 = pow(Saturated_Enhancement_Potential_GS_times2, P);
                      Carrier_Density_Primitive_GD_times4 = pow(Saturated_Enhancement_Potential_GD_times2, P);
                   end

            end // determination of Carrier_Density_Primitive_GS_times4 and Carrier_Density_Primitive_GD_times4 }


            // Current density, temperature scaling, and channel length reduction

            //     ##   #######     ######
            //     ##   ##    ##   ##
            //     ##   ##    ##    #####
            //     ##   ##    ##        ##
            //     ##   #######     #####

            ids   =  _DRAIN_CURRENT_SCALE * ( Carrier_Density_Primitive_GS_times4 - Carrier_Density_Primitive_GD_times4 )
                       // times temperature derating of saturated velocity
                       *    ( _VELOCITY_OFFSET + _VELCOCITY_TEMP_COEEFICIENT_times4 / Smooth_Max_times2(Tjunction_upper_bounded_times2, _VELOCITY_TRANSITION_T_times2, _VELOCITY_TRANSITION_T_squared_times4) )
                       // divided by Channel-length modulation
                       /    ( Soft_ABS( Saturated_Enhancement_Potential_GS_times2 - Saturated_Enhancement_Potential_GD_times2, _XI_times_XI_MU_squared_times4 ) - _XI_times_XI_MU_times2
                              + _XI_times_LAMBDA_over_LAMBDA_S_times2 / ( _LAMBDA_over_LAMBDA_S + lne(1.0-(LowField_Saturation_Potential_XS-vds)/LAMBDA_S) + lne(1.0-(LowField_Saturation_Potential_XD+vds)/LAMBDA_S) )  );


            begin  // { determine Channel_Current_GS and Channel_Current_GD

                if (II_A > II_D) // Avalanche Multiplier is applicable
                    begin
                        real Avalanche_Current, Tunnelling_Rate;
                        
                        begin // Avalanche Current
                            real ni, Ionisation_Rate;

                            Ionisation_Rate                   =  II_A / exp( ( _II_COLD_B_times2 + _II_B_TEMP_COEF_over2 * bounded_Tjunction_times4 )
                                                                      / ( Soft_ABS(vds - _II_OFFSET, _II_Z_squared) + Soft_ABS(vds + _II_OFFSET, _II_Z_squared) - _II_OFFSETtimes2 ) );

                            ni                                =  _IMPACT_IONIZATION_SCALE / sqrt(Carrier_Density_Primitive_GS_times4 + Carrier_Density_Primitive_GD_times4);

                            if ( Ionisation_Rate * ni < ni - 1.0 )
                                Avalanche_Current             =  ids * Ionisation_Rate / (1.0 - Ionisation_Rate);
                            else
                                Avalanche_Current             =  ids * ( ni * (3.0 + ni * ( ni - 3.0  + Ionisation_Rate * (3.0 - ni * (2.0 - Ionisation_Rate) ) ) ) - 1.0 ) ;

                        end // Avalanche_Current

                        begin // Gate tunnelling rate
                            real x;

                            x                             =  Enhancement_Potential_GS - _DEPLETION_POTENTIAL;
                            if ( x > _E_over_lnD )
                                 Tunnelling_Rate          =  _D_times_E_over_lnD_over_lnD / ( _E_over_lnD_over_lnD_minus_EoverlnD + x );
                            else
                                 Tunnelling_Rate          =  exp( II_E / x );

                            x                             =  Enhancement_Potential_GD - _DEPLETION_POTENTIAL;
                            if ( x > _E_over_lnD )
                                 Tunnelling_Rate          =  _D_times_E_over_lnD_over_lnD / ( _E_over_lnD_over_lnD_minus_EoverlnD + x ) * Tunnelling_Rate ;
                            else
                                 Tunnelling_Rate          =  exp( II_E / x ) * Tunnelling_Rate;

                        end // Gate Tunnelling_Rate

                        if ( vds > 0 ) // Avalanche at drain end
                            begin
                                Channel_Current_GD        =  - Avalanche_Current                           - ids;
                                Channel_Current_GS        =  - Avalanche_Current * II_EO * Tunnelling_Rate - Channel_Current_GD;
                            end
                        else // Avalanche at source end
                            begin
                                Channel_Current_GS        =    Avalanche_Current                           + ids;
                                Channel_Current_GD        =    Avalanche_Current * II_EO * Tunnelling_Rate - Channel_Current_GS;
                            end
                    end
                else
                    begin
                        Channel_Current_GS                =  +ids;
                        Channel_Current_GD                =  -ids;
                    end

            end // Channel_Current_GS and Channel_Current_GD }

        end // determination of Channel_Current_GS and Channel_Current_GD, Enhancement_Potential_GS and Enhancement_Potential_GD }

        // /////////////////////////////////////////////////////////////////////// /////////////////////////////////////////////////////////////////////// ///////////////////////////////////////////////////////////////////

        begin // { Gate junction diode currents
            real TNOMoverT;               // TO BE CHECKED
            real ScaleFactor, BiasFactor, ActivationFactor;               // TO BE CHECKED
            real Temperature_factor_GS, Temperature_factor_GD, Power_factor;               // TO BE CHECKED
            real Potential_from_Peak, Abs_Potential_from_Peak, primitive;               // TO BE CHECKED

            TNOMoverT                                      = _BOUNDED_TNOM_times4 / bounded_Tjunction_times4;               // TO BE CHECKED

            // Forward Currents
            ActivationFactor = _DIODE_FWD_ActivationFactor * TNOMoverT;               // TO BE CHECKED

            BiasFactor       =  V(g,s) * _DIODE_FWD_1overVT * TNOMoverT;               // TO BE CHECKED
            ScaleFactor      =  DiodeEXP( BiasFactor, ActivationFactor, _DIODE_FWD_M, _DIODE_FWD_EXP_M);               // TO BE CHECKED
               // TO BE CHECKED
            Diode_GS_Fwd_Current = _DIODE_FWD_ISAT * pow(TNOMoverT, -DIODE_FWD_XTI) * ScaleFactor;               // TO BE CHECKED
               // TO BE CHECKED
            Temperature_factor_GS = _DIODE_RTH_times_ENHANCEMENT_POLARITY * V(g,s) / bounded_Tjunction_times4 ;               // TO BE CHECKED
            Power_factor = Temperature_factor_GS * Diode_GS_Fwd_Current;               // TO BE CHECKED
            if ( Power_factor > 0.003 )               // TO BE CHECKED
                Diode_GS_Fwd_Pwr_Scale = 1.0 + exp( DIODE_FWD_XTI - 0.25 / Power_factor ) / ScaleFactor;               // TO BE CHECKED
            else               // TO BE CHECKED
                Diode_GS_Fwd_Pwr_Scale = 1.0;               // TO BE CHECKED

            BiasFactor       =  V(g,d) * _DIODE_FWD_1overVT * TNOMoverT;               // TO BE CHECKED
            ScaleFactor      =  DiodeEXP( BiasFactor, ActivationFactor, _DIODE_FWD_M, _DIODE_FWD_EXP_M);               // TO BE CHECKED
               // TO BE CHECKED
            Diode_GD_Fwd_Current = _DIODE_FWD_ISAT * pow(TNOMoverT, -DIODE_FWD_XTI) * ScaleFactor;               // TO BE CHECKED
               // TO BE CHECKED
            Temperature_factor_GD = _DIODE_RTH_times_ENHANCEMENT_POLARITY * V(g,d) / bounded_Tjunction_times4 ;               // TO BE CHECKED
            Power_factor = Temperature_factor_GD * Diode_GD_Fwd_Current;               // TO BE CHECKED
            if ( Power_factor > 0.003 )               // TO BE CHECKED
                Diode_GD_Fwd_Pwr_Scale = 1.0 + exp( DIODE_FWD_XTI - 0.25 / Power_factor ) / ScaleFactor;               // TO BE CHECKED
            else               // TO BE CHECKED
                Diode_GD_Fwd_Pwr_Scale = 1.0;               // TO BE CHECKED


            // Reverse Currents
            ActivationFactor = _DIODE_REV_ActivationFactor * TNOMoverT;               // TO BE CHECKED
               // TO BE CHECKED
            BiasFactor       =  V(g,s) * _DIODE_REV_1overVB * TNOMoverT;               // TO BE CHECKED
            ScaleFactor      =  DiodeEXP( BiasFactor, ActivationFactor, _DIODE_REV_M, _DIODE_REV_EXP_M);               // TO BE CHECKED
               // TO BE CHECKED
            Diode_GS_Rev_Current = _DIODE_REV_ISAT * pow(TNOMoverT, -DIODE_REV_XTI) * ScaleFactor;               // TO BE CHECKED
               // TO BE CHECKED
            Power_factor = Temperature_factor_GS * Diode_GS_Rev_Current;               // TO BE CHECKED
            if ( Power_factor > 0.003 )               // TO BE CHECKED
                Diode_GS_Rev_Pwr_Scale = 1.0 + exp( DIODE_REV_XTI  - 0.25 / Power_factor ) / ScaleFactor;               // TO BE CHECKED
            else               // TO BE CHECKED
                Diode_GS_Rev_Pwr_Scale = 1.0;               // TO BE CHECKED
               // TO BE CHECKED
               // TO BE CHECKED
            BiasFactor       =  V(g,d) * _DIODE_REV_1overVB * TNOMoverT;               // TO BE CHECKED
            ScaleFactor      =  DiodeEXP( BiasFactor, ActivationFactor, _DIODE_REV_M, _DIODE_REV_EXP_M);               // TO BE CHECKED
               // TO BE CHECKED
            Diode_GD_Rev_Current = _DIODE_REV_ISAT * pow(TNOMoverT, -DIODE_REV_XTI) * ScaleFactor;               // TO BE CHECKED
               // TO BE CHECKED
            Power_factor = Temperature_factor_GD * Diode_GD_Rev_Current;               // TO BE CHECKED
            if ( Power_factor > 0.003 )               // TO BE CHECKED
                Diode_GD_Rev_Pwr_Scale = 1.0 + exp( DIODE_REV_XTI  - 0.25 / Power_factor ) / ScaleFactor;               // TO BE CHECKED
            else               // TO BE CHECKED
                Diode_GD_Rev_Pwr_Scale = 1.0;               // TO BE CHECKED
        end // Gate junction diode currents }

        // /////////////////////////////////////////////////////////////////////// /////////////////////////////////////////////////////////////////////// ///////////////////////////////////////////////////////////////////

        begin // { charge calculations with separate charge related parameters ( CJ_XXXX )
            real  Enhancement_Factor_GS, Enhancement_Factor_GD, Enhancement_Potential_GS, Enhancement_Potential_GD, Enhancement_Factor_GC, Enhancement_Potential_GC;
            real  LowField_Saturation_Potential_XS, LowField_Saturation_Potential_XD, LowField_Saturation_Potential_XC;
            real  Saturated_Enhancement_Potential_GS_times2, Saturated_Enhancement_Potential_GD_times2, Saturated_Enhancement_Potential_GC_times2;
            real  vds; 
            real  Charge_Primitive_GS, Charge_Primitive_GD, Charge_Primitive_GE, Carrier_Density_Primitive_GS, Carrier_Density_Primitive_GD, Carrier_Density_Primitive_GE, Charge_Primitive_GC;
            real  Drain_End__Saturation_Position, Source_End_Saturation_Position, Extended_LowField_Position;
            real  Extended_Enhancemnet_Potential_times2;
            real  smooth_sign;

            //channel current ids corresponds to vds. Both ids and vds are +ve when the drain end is the more depleted (higher field) end
            vds  =  _ENHANCEMENT_POLARITY * ( V(g,s) - V(g,d) );
            smooth_sign = tanh ( vds / CJ_ZREV);


            begin // { Re-determine Enhancement_Factor_GS, Enhancement_Factor_GD, Enhancement_Potential_GS and Enhancement_Potential_GD
                // these are the potentials above pinch-off that enhance carrier density at source, drain, and for fully open. Zero is pinched-off
                real   vopen, Pinchoff_Potential, Sigma, Drain_Feedback_Potential;

                Pinchoff_Potential                        = _C_COLD_PINCH_OFF + bounded_Tjunction_times4 * _PINCH_OFF_WARMINGover4;
                Sigma                                     = CJ_VST / VST * (_COLD_SIGMA     + bounded_Tjunction_times4 * _SIGMA_WARMINGover4);
                Drain_Feedback_Potential                  = vds * CJ_GAMMA;

                Enhancement_Factor_GS                     = (vgs_plus_vtrap + Drain_Feedback_Potential - Pinchoff_Potential)
                                                                      / ( Sigma - Sigma * _C_GAMMA_FACTORover2 * Smooth_Min_times2(vgd_plus_vtrap, _C_DEPLETION_POTENTIAL, _DEPLETION_POTENTIAL_squared_over100) );
                Enhancement_Potential_GS                  = Sigma * lne(Enhancement_Factor_GS);

                Enhancement_Factor_GD                     = (vgd_plus_vtrap - Drain_Feedback_Potential - Pinchoff_Potential)
                                                                      / ( Sigma - Sigma * _C_GAMMA_FACTORover2 * Smooth_Min_times2(vgs_plus_vtrap, _C_DEPLETION_POTENTIAL, _DEPLETION_POTENTIAL_squared_over100) );
                Enhancement_Potential_GD                  = Sigma * lne(Enhancement_Factor_GD);
                
                vopen                                     = 0.5 * CJ_GAMMA / _C_GAMMA_FACTORover2;
                Enhancement_Factor_GC                     = vopen  / ( Sigma - Sigma * _C_GAMMA_FACTORover2 * Smooth_Min_times2(vopen, _C_DEPLETION_POTENTIAL, _DEPLETION_POTENTIAL_squared_over100) );
                Enhancement_Potential_GC                  = Sigma * lne(Enhancement_Factor_GC);

            end // determination of Enhancement_Factor_GS, Enhancement_Factor_GD, Enhancement_Potential_GS and Enhancement_Potential_GD }

            begin // { determination of LowField_Saturation_Potential_XS and LowField_Saturation_Potential_XD : End to end potential of low-field region -- equivalent to a vds of the low-field region where drain is at X
                real Abs_Potential_from_GMPeak, Potential_from_GMPeak, vgsu, vgdu, vgcu;

                // reduced arguments : vgsu, vgdu
                if ( _C_GM_TURNING_FACTOR_RATIO )
                    begin
                        Potential_from_GMPeak             = Enhancement_Potential_GS - _C_GM_TURNING_POTENTIAL;
                        Abs_Potential_from_GMPeak         = Soft_ABS(Potential_from_GMPeak, _C_GM_TURNING_WIDTH_SQUARED);
                        vgsu                              = ( Enhancement_Potential_GS + _C_GM_TURNING_POTENTIAL_over_XI * ( Enhancement_Potential_GS  + _C_GM_TURNING_FACTOR_RATIO * (_C_GM_OFFSET - Abs_Potential_from_GMPeak) )
                                                                                             * Abs_Potential_from_GMPeak / ( Abs_Potential_from_GMPeak - _C_GM_TURNING_FACTOR_RATIO * Potential_from_GMPeak                    )
                                                             ) / _C_GM_TURNING_POTENTIAL_plus_XI;

                        Potential_from_GMPeak             = Enhancement_Potential_GD - _C_GM_TURNING_POTENTIAL;
                        Abs_Potential_from_GMPeak         = Soft_ABS(Potential_from_GMPeak, _C_GM_TURNING_WIDTH_SQUARED);
                        vgdu                              = ( Enhancement_Potential_GD + _C_GM_TURNING_POTENTIAL_over_XI * ( Enhancement_Potential_GD  + _C_GM_TURNING_FACTOR_RATIO * (_C_GM_OFFSET - Abs_Potential_from_GMPeak) )
                                                                                             * Abs_Potential_from_GMPeak / ( Abs_Potential_from_GMPeak - _C_GM_TURNING_FACTOR_RATIO * Potential_from_GMPeak                    )
                                                             ) / _C_GM_TURNING_POTENTIAL_plus_XI;

                        Potential_from_GMPeak             = Enhancement_Potential_GC - _C_GM_TURNING_POTENTIAL;
                        Abs_Potential_from_GMPeak         = Soft_ABS(Potential_from_GMPeak, _C_GM_TURNING_WIDTH_SQUARED);
                        vgcu                              = ( Enhancement_Potential_GC + _C_GM_TURNING_POTENTIAL_over_XI * ( Enhancement_Potential_GC  + _C_GM_TURNING_FACTOR_RATIO * (_C_GM_OFFSET - Abs_Potential_from_GMPeak) )
                                                                                             * Abs_Potential_from_GMPeak / ( Abs_Potential_from_GMPeak - _C_GM_TURNING_FACTOR_RATIO * Potential_from_GMPeak                    )
                                                             ) / _C_GM_TURNING_POTENTIAL_plus_XI;
                    end
                else
                    begin
                        vgsu                              = Enhancement_Potential_GS / CJ_XI;
                        vgdu                              = Enhancement_Potential_GD / CJ_XI;
                        vgcu                              = Enhancement_Potential_GC / CJ_XI;
                    end

                // potential calculation : LowField_Saturation_Potential_XS and LowField_Saturation_Potential_XD
                if ( _XI_X_near1 )
                    begin
                        LowField_Saturation_Potential_XS  = _C_6XIover4plusP * vgsu / pow( 1.0 + vgsu, _C_1plusPover4plusP_times2 );
                        LowField_Saturation_Potential_XD  = _C_6XIover4plusP * vgdu / pow( 1.0 + vgdu, _C_1plusPover4plusP_times2 );
                        LowField_Saturation_Potential_XC  = _C_6XIover4plusP * vgcu / pow( 1.0 + vgcu, _C_1plusPover4plusP_times2 );
                    end
                else
                    begin
                        LowField_Saturation_Potential_XS  = _C_XI_X_factor * ( pow( 1.0 + vgsu * (2.0 + _XI_X_squared * vgsu), _C_3over4plusP ) - pow( 1.0 + XI_X * vgsu, _C_6over4plusP ) );
                        LowField_Saturation_Potential_XD  = _C_XI_X_factor * ( pow( 1.0 + vgdu * (2.0 + _XI_X_squared * vgdu), _C_3over4plusP ) - pow( 1.0 + XI_X * vgdu, _C_6over4plusP ) );
                        LowField_Saturation_Potential_XC  = _C_XI_X_factor * ( pow( 1.0 + vgcu * (2.0 + _XI_X_squared * vgcu), _C_3over4plusP ) - pow( 1.0 + XI_X * vgcu, _C_6over4plusP ) );
                    end

            end // determination of LowField_Saturation_Potential_XS and LowField_Saturation_Potential_XD , vgsu, vgdu, vgcu }

            begin // { Minimum potentials at end of low-field region of the channel : Saturated_Enhancement_Potential_GS_times2 and Saturated_Enhancement_Potential_GD_times2
                real   Saturation_Potential_GX;

                Saturation_Potential_GX                   = Enhancement_Potential_GD - LowField_Saturation_Potential_XD ;
                Saturated_Enhancement_Potential_GS_times2 = Smooth_Max_times2( Enhancement_Potential_GS,  Saturation_Potential_GX, _XI_SS_squared);

                Saturation_Potential_GX                   = Enhancement_Potential_GS - LowField_Saturation_Potential_XS;
                Saturated_Enhancement_Potential_GD_times2 = Smooth_Max_times2( Enhancement_Potential_GD,  Saturation_Potential_GX, _XI_SS_squared);

                Saturation_Potential_GX                   = Enhancement_Potential_GC - LowField_Saturation_Potential_XC;
                Saturated_Enhancement_Potential_GC_times2 = Smooth_Max_times2( Enhancement_Potential_GC,  Saturation_Potential_GX, _XI_SS_squared);

            end // determination of Saturated_Enhancement_Potential_GS_times2 and Saturated_Enhancement_Potential_GD_times2 }

            begin // { determine critical lengths along the channel
                real argument_times2, potential_times2;
                
                //AEP version 22 CJ_ to LAMBDA_S
                Drain_End__Saturation_Position   =  _C_LAMBDA_over_LAMBDA_S / ( _C_LAMBDA_over_LAMBDA_S + lne(1.0-(LowField_Saturation_Potential_XS-vds)/CJ_LAMBDA_S) )  -  0.5;
                Source_End_Saturation_Position   =  0.5  -  _C_LAMBDA_over_LAMBDA_S / ( _C_LAMBDA_over_LAMBDA_S + lne(1.0-(LowField_Saturation_Potential_XD+vds)/CJ_LAMBDA_S) );
                argument_times2                  = Drain_End__Saturation_Position * (Saturated_Enhancement_Potential_GS_times2 - 0.5 * CJ_XI_SS) + (0.5 * CJ_XI_SS - Saturated_Enhancement_Potential_GD_times2) * Source_End_Saturation_Position;
                potential_times2                 =              CJ_LF_EXTENSION * ( Saturated_Enhancement_Potential_GS_times2 - Saturated_Enhancement_Potential_GD_times2 );
                Extended_LowField_Position       =  (    2.0 / Smooth_Max_times2( potential_times2 / argument_times2, 1.0, CJ_ZL*CJ_ZL)
                                                       - 2.0 / Smooth_Max_times2(-potential_times2 / argument_times2, 1.0, CJ_ZL*CJ_ZL)  + smooth_sign ) * CJ_LF_EXTENSION;
                // Potential at extended low-field position - assuming linear potential model
                Extended_Enhancemnet_Potential_times2 = ( Extended_LowField_Position * potential_times2 / CJ_LF_EXTENSION - argument_times2 )
                                                                         / ( Source_End_Saturation_Position - Drain_End__Saturation_Position ) + CJ_XI_SS * 0.5;


            end // determination of critical positions }
            
            begin // { Carrier density primitives
                real argument;
 
                if ( _C_GM_TURNING_FACTOR_RATIO )
                   begin
                      argument                     = 0.5 * ( Saturated_Enhancement_Potential_GS_times2 - _C_GM_TURNING_FACTOR_RATIO
                                                                   * ( Soft_ABS(Saturated_Enhancement_Potential_GS_times2 - _C_GM_TURNING_POTENTIAL_times2, _C_GM_TURNING_WIDTH_SQUARED_times4) - _C_GM_OFFSET_times2) );
                      Charge_Primitive_GS          = pow(argument, CJ_P - 1.0);
                      Carrier_Density_Primitive_GS = argument * Charge_Primitive_GS;

                      argument                     = 0.5 * ( Saturated_Enhancement_Potential_GD_times2 - _C_GM_TURNING_FACTOR_RATIO
                                                                   * ( Soft_ABS(Saturated_Enhancement_Potential_GD_times2 - _C_GM_TURNING_POTENTIAL_times2, _C_GM_TURNING_WIDTH_SQUARED_times4) - _C_GM_OFFSET_times2) );
                      Charge_Primitive_GD          = pow(argument, CJ_P - 1.0);
                      Carrier_Density_Primitive_GD = argument * Charge_Primitive_GD;
                      
                      argument                     = 0.5 * ( Extended_Enhancemnet_Potential_times2 - _C_GM_TURNING_FACTOR_RATIO
                                                                   * ( Soft_ABS(Extended_Enhancemnet_Potential_times2     - _C_GM_TURNING_POTENTIAL_times2, _C_GM_TURNING_WIDTH_SQUARED_times4) - _C_GM_OFFSET_times2) );
                      Charge_Primitive_GE          = pow(argument, CJ_P - 1.0);
                      Carrier_Density_Primitive_GE = argument * Charge_Primitive_GE;

                      argument                     = 0.5 * ( Saturated_Enhancement_Potential_GC_times2 - _C_GM_TURNING_FACTOR_RATIO
                                                                   * ( Soft_ABS(Saturated_Enhancement_Potential_GC_times2 - _C_GM_TURNING_POTENTIAL_times2, _C_GM_TURNING_WIDTH_SQUARED_times4) - _C_GM_OFFSET_times2) );
                      Charge_Primitive_GC          = pow(argument, CJ_P - 1.0);
                   end
                else
                   begin
                      Charge_Primitive_GS          = pow(Saturated_Enhancement_Potential_GS_times2 * 0.5, CJ_P - 1.0);
                      Charge_Primitive_GD          = pow(Saturated_Enhancement_Potential_GD_times2 * 0.5, CJ_P - 1.0);
                      Charge_Primitive_GC          = pow(Saturated_Enhancement_Potential_GC_times2 * 0.5, CJ_P - 1.0);
                      Charge_Primitive_GE          = pow(Extended_Enhancemnet_Potential_times2     * 0.5, CJ_P - 1.0);
                      Carrier_Density_Primitive_GS = Charge_Primitive_GS * Saturated_Enhancement_Potential_GS_times2 * 0.5;
                      Carrier_Density_Primitive_GD = Charge_Primitive_GD * Saturated_Enhancement_Potential_GD_times2 * 0.5;
                      Carrier_Density_Primitive_GE = Charge_Primitive_GE * Extended_Enhancemnet_Potential_times2     * 0.5;

                   end

            end // determination of Carrier_Density_Primitive_GS_times4 and Carrier_Density_Primitive_GD_times4 }


            begin // { 
                real   qgo, qgs, qgd, qgg, arg;
              
                Charge_Primitive_GS                =  CJ_P * Charge_Primitive_GS; // * lne_derivative ( Enhancement_Factor_GS );
                Charge_Primitive_GD                =  CJ_P * Charge_Primitive_GD; // * lne_derivative ( Enhancement_Factor_GD );
                Charge_Primitive_GE                =  CJ_P * Charge_Primitive_GE; // * lne_derivative ( Enhancement_Factor_GE );
                Charge_Primitive_GC                =  Charge_Primitive_GC; // * lne_derivative ( Enhancement_Factor_GC );

                
//                qgg = ( Drain_End__Saturation_Position - Source_End_Saturation_Position )  * ( Carrier_Density_Primitive_GS   - Carrier_Density_Primitive_GD   )
//                                             / skip_zero((Saturated_Enhancement_Potential_GS_times2-Saturated_Enhancement_Potential_GD_times2)*0.5, CJ_VS)
                if (abs(Saturated_Enhancement_Potential_GS_times2-Saturated_Enhancement_Potential_GD_times2) < CJ_VS)
                    qgo = ( Charge_Primitive_GS   + Charge_Primitive_GD   ) * 0.5;
                else                                   
                    qgo = 2.0  * ( Carrier_Density_Primitive_GS   - Carrier_Density_Primitive_GD   )
                                                 / (Saturated_Enhancement_Potential_GS_times2 - Saturated_Enhancement_Potential_GD_times2);

                qgg = qgo * ( Drain_End__Saturation_Position - Source_End_Saturation_Position ) -  Charge_Primitive_GC
                             + CJ_CSAT * smooth_sign * (Charge_Primitive_GS * (0.5 - Drain_End__Saturation_Position) - Charge_Primitive_GD * (0.5 + Source_End_Saturation_Position));

                if ( smooth_sign > 0 )
                    begin 
                        if (abs(Saturated_Enhancement_Potential_GS_times2-Extended_Enhancemnet_Potential_times2) < CJ_VS)
                            qgo = Charge_Primitive_GS;
                        else                                   
                            qgo = 2.0  * ( Carrier_Density_Primitive_GS   - Carrier_Density_Primitive_GE  )
                                                           / (Saturated_Enhancement_Potential_GS_times2-Extended_Enhancemnet_Potential_times2);
                        qgs = Charge_Primitive_GC * ( Source_End_Saturation_Position - CJ_LF_EXTENSION * smooth_sign)
                                                         +   ( Extended_LowField_Position - Source_End_Saturation_Position ) * qgo;
//                                                           * ( Carrier_Density_Primitive_GS   - Carrier_Density_Primitive_GE  )
//                                                           / skip_zero((Saturated_Enhancement_Potential_GS_times2-Extended_Enhancemnet_Potential_times2)*0.5, CJ_VS);
                        qgd = qgg - qgs;
                    end
                else
                    begin 
                        if (abs(Saturated_Enhancement_Potential_GD_times2-Extended_Enhancemnet_Potential_times2) < CJ_VS)
                            qgo = Charge_Primitive_GD;
                        else                                   
                            qgo = 2.0  * ( Carrier_Density_Primitive_GD   - Carrier_Density_Primitive_GE  )
                                                           / (Saturated_Enhancement_Potential_GD_times2-Extended_Enhancemnet_Potential_times2);
                        qgd = Charge_Primitive_GC * ( CJ_LF_EXTENSION * smooth_sign - Drain_End__Saturation_Position )
                                                         -   ( Extended_LowField_Position - Drain_End__Saturation_Position )  * qgo;
//                                                           * ( Carrier_Density_Primitive_GD   - Carrier_Density_Primitive_GE   )
//                                                           / skip_zero((Saturated_Enhancement_Potential_GD_times2-Extended_Enhancemnet_Potential_times2)*0.5, CJ_VS);
                        qgs = qgg - qgd;
                    end
                    
                QDS = CJ_CDS * CJ_CDSV * (tanh ( vds / CJ_CDSV ) + 1.0e-6 * vds);
                                                           
                Diode_GS_Charge = qgs * GJ_CAPACITANCE + V(g,s) * CGSO;
                Diode_GD_Charge = qgd * GJ_CAPACITANCE + V(g,d) * CGDO;

            end // }
        end // charge }

        // /////////////////////////////////////////////////////////////////////// /////////////////////////////////////////////////////////////////////// ///////////////////////////////////////////////////////////////////

        I(Trap_Potential)               <+  V(Trap_Potential);   // One-ohm resistance at Trap Potential node

        I(g,s)                          <+  Diode_GS_Fwd_Current + Diode_GS_Rev_Current  +  Channel_Current_GS  +  V(g,s) * `GMIN;
        I(g,d)                          <+  Diode_GD_Fwd_Current + Diode_GD_Rev_Current  +  Channel_Current_GD  +  V(g,d) * `GMIN;

        I(g,s)                          <+  ddt(Diode_GS_Charge);               // TO BE CHECKED
        I(g,d)                          <+  ddt(Diode_GD_Charge);               // TO BE CHECKED
        I(d,s)                          <+  ddt(QDS);               // TO BE CHECKED

        I(Impact_Ionization_Tunnelling) <+  V(Impact_Ionization_Tunnelling) * `GMIN - Channel_Current_GS - Channel_Current_GD;

        Pwr(Tj)                         <+  Temp(Tj) * `GMIN - `kWatts * (
                                                           + V(g,s) * ( Channel_Current_GS + Diode_GS_Rev_Current / Diode_GS_Rev_Pwr_Scale + Diode_GS_Fwd_Current / Diode_GS_Fwd_Pwr_Scale)
                                                           + V(g,d) * ( Channel_Current_GD + Diode_GD_Rev_Current / Diode_GD_Rev_Pwr_Scale + Diode_GD_Fwd_Current / Diode_GD_Fwd_Pwr_Scale) );

//        I(g,s)                          <+  flicker_noise(DIODE_KF * 2.0 * `P_Q * pow(abs(Diode_GS_Fwd_Current + Diode_GS_Rev_Current), DIODE_AF), DIODE_EF, "shot" );               // TO BE CHECKED
//        I(g,d)                          <+  flicker_noise(DIODE_KF * 2.0 * `P_Q * pow(abs(Diode_GD_Fwd_Current + Diode_GD_Rev_Current), DIODE_AF), DIODE_EF, "shot" );               // TO BE CHECKED

    end // analog

endmodule
